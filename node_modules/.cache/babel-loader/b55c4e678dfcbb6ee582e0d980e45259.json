{"ast":null,"code":"(function (document, Math, undefined) {\n  (function (factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define([\"jquery\"], factory);\n    } else if (jQuery && !jQuery.fn.sparkline) {\n      factory(jQuery);\n    }\n  })(function ($) {\n    \"use strict\";\n\n    var UNSET_OPTION = {},\n        getDefaults,\n        createClass,\n        SPFormat,\n        clipval,\n        quartile,\n        normalizeValue,\n        normalizeValues,\n        remove,\n        isNumber,\n        all,\n        sum,\n        addCSS,\n        ensureArray,\n        formatNumber,\n        RangeMap,\n        MouseHandler,\n        Tooltip,\n        barHighlightMixin,\n        line,\n        bar,\n        tristate,\n        discrete,\n        bullet,\n        pie,\n        box,\n        defaultStyles,\n        initStyles,\n        VShape,\n        VCanvas_base,\n        VCanvas_canvas,\n        VCanvas_vml,\n        pending,\n        shapeCount = 0;\n\n    getDefaults = function () {\n      return {\n        common: {\n          type: \"line\",\n          lineColor: \"#00f\",\n          fillColor: \"#cdf\",\n          defaultPixelsPerValue: 3,\n          width: \"auto\",\n          height: \"auto\",\n          composite: false,\n          tagValuesAttribute: \"values\",\n          tagOptionsPrefix: \"spark\",\n          enableTagOptions: false,\n          enableHighlight: true,\n          highlightLighten: 1.4,\n          tooltipSkipNull: true,\n          tooltipPrefix: \"\",\n          tooltipSuffix: \"\",\n          disableHiddenCheck: false,\n          numberFormatter: false,\n          numberDigitGroupCount: 3,\n          numberDigitGroupSep: \",\",\n          numberDecimalMark: \".\",\n          disableTooltips: false,\n          disableInteraction: false\n        },\n        line: {\n          spotColor: \"#f80\",\n          highlightSpotColor: \"#5f5\",\n          highlightLineColor: \"#f22\",\n          spotRadius: 1.5,\n          minSpotColor: \"#f80\",\n          maxSpotColor: \"#f80\",\n          lineWidth: 1,\n          normalRangeMin: undefined,\n          normalRangeMax: undefined,\n          normalRangeColor: \"#ccc\",\n          drawNormalOnTop: false,\n          chartRangeMin: undefined,\n          chartRangeMax: undefined,\n          chartRangeMinX: undefined,\n          chartRangeMaxX: undefined,\n          tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{y}}{{suffix}}')\n        },\n        bar: {\n          barColor: \"#3366cc\",\n          negBarColor: \"#f44\",\n          stackedBarColor: [\"#3366cc\", \"#dc3912\", \"#ff9900\", \"#109618\", \"#66aa00\", \"#dd4477\", \"#0099c6\", \"#990099\"],\n          zeroColor: undefined,\n          nullColor: undefined,\n          zeroAxis: true,\n          barWidth: 4,\n          barSpacing: 1,\n          chartRangeMax: undefined,\n          chartRangeMin: undefined,\n          chartRangeClip: false,\n          colorMap: undefined,\n          tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{value}}{{suffix}}')\n        },\n        tristate: {\n          barWidth: 4,\n          barSpacing: 1,\n          posBarColor: \"#6f6\",\n          negBarColor: \"#f44\",\n          zeroBarColor: \"#999\",\n          colorMap: {},\n          tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{value:map}}'),\n          tooltipValueLookups: {\n            map: {\n              \"-1\": \"Loss\",\n              0: \"Draw\",\n              1: \"Win\"\n            }\n          }\n        },\n        discrete: {\n          lineHeight: \"auto\",\n          thresholdColor: undefined,\n          thresholdValue: 0,\n          chartRangeMax: undefined,\n          chartRangeMin: undefined,\n          chartRangeClip: false,\n          tooltipFormat: new SPFormat(\"{{prefix}}{{value}}{{suffix}}\")\n        },\n        bullet: {\n          targetColor: \"#f33\",\n          targetWidth: 3,\n          performanceColor: \"#33f\",\n          rangeColors: [\"#d3dafe\", \"#a8b6ff\", \"#7f94ff\"],\n          base: undefined,\n          tooltipFormat: new SPFormat(\"{{fieldkey:fields}} - {{value}}\"),\n          tooltipValueLookups: {\n            fields: {\n              r: \"Range\",\n              p: \"Performance\",\n              t: \"Target\"\n            }\n          }\n        },\n        pie: {\n          offset: 0,\n          sliceColors: [\"#3366cc\", \"#dc3912\", \"#ff9900\", \"#109618\", \"#66aa00\", \"#dd4477\", \"#0099c6\", \"#990099\"],\n          borderWidth: 0,\n          borderColor: \"#000\",\n          tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{value}} ({{percent.1}}%)')\n        },\n        box: {\n          raw: false,\n          boxLineColor: \"#000\",\n          boxFillColor: \"#cdf\",\n          whiskerColor: \"#000\",\n          outlierLineColor: \"#333\",\n          outlierFillColor: \"#fff\",\n          medianColor: \"#f00\",\n          showOutliers: true,\n          outlierIQR: 1.5,\n          spotRadius: 1.5,\n          target: undefined,\n          targetColor: \"#4a2\",\n          chartRangeMax: undefined,\n          chartRangeMin: undefined,\n          tooltipFormat: new SPFormat(\"{{field:fields}}: {{value}}\"),\n          tooltipFormatFieldlistKey: \"field\",\n          tooltipValueLookups: {\n            fields: {\n              lq: \"Lower Quartile\",\n              med: \"Median\",\n              uq: \"Upper Quartile\",\n              lo: \"Left Outlier\",\n              ro: \"Right Outlier\",\n              lw: \"Left Whisker\",\n              rw: \"Right Whisker\"\n            }\n          }\n        }\n      };\n    };\n\n    defaultStyles = \".jqstooltip { \" + \"position: absolute;\" + \"left: 0px;\" + \"top: 0px;\" + \"visibility: hidden;\" + \"background: rgb(0, 0, 0) transparent;\" + \"background-color: rgba(0,0,0,0.6);\" + \"filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);\" + '-ms-filter: \"progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)\";' + \"color: white;\" + \"font: 10px arial, san serif;\" + \"text-align: left;\" + \"white-space: nowrap;\" + \"padding: 5px;\" + \"border: 1px solid white;\" + \"box-sizing: content-box;\" + \"z-index: 10000;\" + \"}\" + \".jqsfield { \" + \"color: white;\" + \"font: 10px arial, san serif;\" + \"text-align: left;\" + \"}\";\n\n    createClass = function () {\n      var Class, args;\n\n      Class = function () {\n        this.init.apply(this, arguments);\n      };\n\n      if (arguments.length > 1) {\n        if (arguments[0]) {\n          Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);\n          Class._super = arguments[0].prototype;\n        } else {\n          Class.prototype = arguments[arguments.length - 1];\n        }\n\n        if (arguments.length > 2) {\n          args = Array.prototype.slice.call(arguments, 1, -1);\n          args.unshift(Class.prototype);\n          $.extend.apply($, args);\n        }\n      } else {\n        Class.prototype = arguments[0];\n      }\n\n      Class.prototype.cls = Class;\n      return Class;\n    };\n\n    $.SPFormatClass = SPFormat = createClass({\n      fre: /\\{\\{([\\w.]+?)(:(.+?))?\\}\\}/g,\n      precre: /(\\w+)\\.(\\d+)/,\n      init: function (format, fclass) {\n        this.format = format;\n        this.fclass = fclass;\n      },\n      render: function (fieldset, lookups, options) {\n        var self = this,\n            fields = fieldset,\n            match,\n            token,\n            lookupkey,\n            fieldvalue,\n            prec;\n        return this.format.replace(this.fre, function () {\n          var lookup;\n          token = arguments[1];\n          lookupkey = arguments[3];\n          match = self.precre.exec(token);\n\n          if (match) {\n            prec = match[2];\n            token = match[1];\n          } else {\n            prec = false;\n          }\n\n          fieldvalue = fields[token];\n\n          if (fieldvalue === undefined) {\n            return \"\";\n          }\n\n          if (lookupkey && lookups && lookups[lookupkey]) {\n            lookup = lookups[lookupkey];\n\n            if (lookup.get) {\n              return lookups[lookupkey].get(fieldvalue) || fieldvalue;\n            } else {\n              return lookups[lookupkey][fieldvalue] || fieldvalue;\n            }\n          }\n\n          if (isNumber(fieldvalue)) {\n            if (options.get(\"numberFormatter\")) {\n              fieldvalue = options.get(\"numberFormatter\")(fieldvalue);\n            } else {\n              fieldvalue = formatNumber(fieldvalue, prec, options.get(\"numberDigitGroupCount\"), options.get(\"numberDigitGroupSep\"), options.get(\"numberDecimalMark\"));\n            }\n          }\n\n          return fieldvalue;\n        });\n      }\n    });\n\n    $.spformat = function (format, fclass) {\n      return new SPFormat(format, fclass);\n    };\n\n    clipval = function (val, min, max) {\n      if (val < min) {\n        return min;\n      }\n\n      if (val > max) {\n        return max;\n      }\n\n      return val;\n    };\n\n    quartile = function (values, q) {\n      var vl;\n\n      if (q === 2) {\n        vl = Math.floor(values.length / 2);\n        return values.length % 2 ? values[vl] : (values[vl - 1] + values[vl]) / 2;\n      } else {\n        if (values.length % 2) {\n          vl = (values.length * q + q) / 4;\n          return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];\n        } else {\n          vl = (values.length * q + 2) / 4;\n          return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];\n        }\n      }\n    };\n\n    normalizeValue = function (val) {\n      var nf;\n\n      switch (val) {\n        case \"undefined\":\n          val = undefined;\n          break;\n\n        case \"null\":\n          val = null;\n          break;\n\n        case \"true\":\n          val = true;\n          break;\n\n        case \"false\":\n          val = false;\n          break;\n\n        default:\n          nf = parseFloat(val);\n\n          if (val == nf) {\n            val = nf;\n          }\n\n      }\n\n      return val;\n    };\n\n    normalizeValues = function (vals) {\n      var i,\n          result = [];\n\n      for (i = vals.length; i--;) {\n        result[i] = normalizeValue(vals[i]);\n      }\n\n      return result;\n    };\n\n    remove = function (vals, filter) {\n      var i,\n          vl,\n          result = [];\n\n      for (i = 0, vl = vals.length; i < vl; i++) {\n        if (vals[i] !== filter) {\n          result.push(vals[i]);\n        }\n      }\n\n      return result;\n    };\n\n    isNumber = function (num) {\n      return !isNaN(parseFloat(num)) && isFinite(num);\n    };\n\n    formatNumber = function (num, prec, groupsize, groupsep, decsep) {\n      var p, i;\n      num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split(\"\");\n      p = (p = $.inArray(\".\", num)) < 0 ? num.length : p;\n\n      if (p < num.length) {\n        num[p] = decsep;\n      }\n\n      for (i = p - groupsize; i > 0; i -= groupsize) {\n        num.splice(i, 0, groupsep);\n      }\n\n      return num.join(\"\");\n    };\n\n    all = function (val, arr, ignoreNull) {\n      var i;\n\n      for (i = arr.length; i--;) {\n        if (ignoreNull && arr[i] === null) continue;\n\n        if (arr[i] !== val) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    sum = function (vals) {\n      var total = 0,\n          i;\n\n      for (i = vals.length; i--;) {\n        total += typeof vals[i] === \"number\" ? vals[i] : 0;\n      }\n\n      return total;\n    };\n\n    ensureArray = function (val) {\n      return $.isArray(val) ? val : [val];\n    };\n\n    addCSS = function (css) {\n      var tag, iefail;\n\n      if (document.createStyleSheet) {\n        try {\n          document.createStyleSheet().cssText = css;\n          return;\n        } catch (e) {\n          iefail = true;\n        }\n      }\n\n      tag = document.createElement(\"style\");\n      tag.type = \"text/css\";\n      document.getElementsByTagName(\"head\")[0].appendChild(tag);\n\n      if (iefail) {\n        document.styleSheets[document.styleSheets.length - 1].cssText = css;\n      } else {\n        tag[typeof document.body.style.WebkitAppearance == \"string\" ? \"innerText\" : \"innerHTML\"] = css;\n      }\n    };\n\n    $.fn.simpledraw = function (width, height, useExisting, interact) {\n      var target, mhandler;\n\n      if (useExisting && (target = this.data(\"_jqs_vcanvas\"))) {\n        return target;\n      }\n\n      if ($.fn.sparkline.canvas === false) {\n        return false;\n      } else if ($.fn.sparkline.canvas === undefined) {\n        var el = document.createElement(\"canvas\");\n\n        if (!!(el.getContext && el.getContext(\"2d\"))) {\n          $.fn.sparkline.canvas = function (width, height, target, interact) {\n            return new VCanvas_canvas(width, height, target, interact);\n          };\n        } else if (document.namespaces && !document.namespaces.v) {\n          document.namespaces.add(\"v\", \"urn:schemas-microsoft-com:vml\", \"#default#VML\");\n\n          $.fn.sparkline.canvas = function (width, height, target, interact) {\n            return new VCanvas_vml(width, height, target);\n          };\n        } else {\n          $.fn.sparkline.canvas = false;\n          return false;\n        }\n      }\n\n      if (width === undefined) {\n        width = $(this).innerWidth();\n      }\n\n      if (height === undefined) {\n        height = $(this).innerHeight();\n      }\n\n      target = $.fn.sparkline.canvas(width, height, this, interact);\n      mhandler = $(this).data(\"_jqs_mhandler\");\n\n      if (mhandler) {\n        mhandler.registerCanvas(target);\n      }\n\n      return target;\n    };\n\n    $.fn.cleardraw = function () {\n      var target = this.data(\"_jqs_vcanvas\");\n\n      if (target) {\n        target.reset();\n      }\n    };\n\n    $.RangeMapClass = RangeMap = createClass({\n      init: function (map) {\n        var key,\n            range,\n            rangelist = [];\n\n        for (key in map) {\n          if (map.hasOwnProperty(key) && typeof key === \"string\" && key.indexOf(\":\") > -1) {\n            range = key.split(\":\");\n            range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);\n            range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);\n            range[2] = map[key];\n            rangelist.push(range);\n          }\n        }\n\n        this.map = map;\n        this.rangelist = rangelist || false;\n      },\n      get: function (value) {\n        var rangelist = this.rangelist,\n            i,\n            range,\n            result;\n\n        if ((result = this.map[value]) !== undefined) {\n          return result;\n        }\n\n        if (rangelist) {\n          for (i = rangelist.length; i--;) {\n            range = rangelist[i];\n\n            if (range[0] <= value && range[1] >= value) {\n              return range[2];\n            }\n          }\n        }\n\n        return undefined;\n      }\n    });\n\n    $.range_map = function (map) {\n      return new RangeMap(map);\n    };\n\n    MouseHandler = createClass({\n      init: function (el, options) {\n        var $el = $(el);\n        this.$el = $el;\n        this.options = options;\n        this.currentPageX = 0;\n        this.currentPageY = 0;\n        this.el = el;\n        this.splist = [];\n        this.tooltip = null;\n        this.over = false;\n        this.displayTooltips = !options.get(\"disableTooltips\");\n        this.highlightEnabled = !options.get(\"disableHighlight\");\n      },\n      registerSparkline: function (sp) {\n        this.splist.push(sp);\n\n        if (this.over) {\n          this.updateDisplay();\n        }\n      },\n      registerCanvas: function (canvas) {\n        var $canvas = $(canvas.canvas);\n        this.canvas = canvas;\n        this.$canvas = $canvas;\n        $canvas.mouseenter($.proxy(this.mouseenter, this));\n        $canvas.mouseleave($.proxy(this.mouseleave, this));\n        $canvas.click($.proxy(this.mouseclick, this));\n      },\n      reset: function (removeTooltip) {\n        this.splist = [];\n\n        if (this.tooltip && removeTooltip) {\n          this.tooltip.remove();\n          this.tooltip = undefined;\n        }\n      },\n      mouseclick: function (e) {\n        var clickEvent = $.Event(\"sparklineClick\");\n        clickEvent.originalEvent = e;\n        clickEvent.sparklines = this.splist;\n        this.$el.trigger(clickEvent);\n      },\n      mouseenter: function (e) {\n        $(document.body).unbind(\"mousemove.jqs\");\n        $(document.body).bind(\"mousemove.jqs\", $.proxy(this.mousemove, this));\n        this.over = true;\n        this.currentPageX = e.pageX;\n        this.currentPageY = e.pageY;\n        this.currentEl = e.target;\n\n        if (!this.tooltip && this.displayTooltips) {\n          this.tooltip = new Tooltip(this.options);\n          this.tooltip.updatePosition(e.pageX, e.pageY);\n        }\n\n        this.updateDisplay();\n      },\n      mouseleave: function () {\n        $(document.body).unbind(\"mousemove.jqs\");\n        var splist = this.splist,\n            spcount = splist.length,\n            needsRefresh = false,\n            sp,\n            i;\n        this.over = false;\n        this.currentEl = null;\n\n        if (this.tooltip) {\n          this.tooltip.remove();\n          this.tooltip = null;\n        }\n\n        for (i = 0; i < spcount; i++) {\n          sp = splist[i];\n\n          if (sp.clearRegionHighlight()) {\n            needsRefresh = true;\n          }\n        }\n\n        if (needsRefresh) {\n          this.canvas.render();\n        }\n      },\n      mousemove: function (e) {\n        this.currentPageX = e.pageX;\n        this.currentPageY = e.pageY;\n        this.currentEl = e.target;\n\n        if (this.tooltip) {\n          this.tooltip.updatePosition(e.pageX, e.pageY);\n        }\n\n        this.updateDisplay();\n      },\n      updateDisplay: function () {\n        var splist = this.splist,\n            spcount = splist.length,\n            needsRefresh = false,\n            offset = this.$canvas.offset(),\n            localX = this.currentPageX - offset.left,\n            localY = this.currentPageY - offset.top,\n            tooltiphtml,\n            sp,\n            i,\n            result,\n            changeEvent;\n\n        if (!this.over) {\n          return;\n        }\n\n        for (i = 0; i < spcount; i++) {\n          sp = splist[i];\n          result = sp.setRegionHighlight(this.currentEl, localX, localY);\n\n          if (result) {\n            needsRefresh = true;\n          }\n        }\n\n        if (needsRefresh) {\n          changeEvent = $.Event(\"sparklineRegionChange\");\n          changeEvent.sparklines = this.splist;\n          this.$el.trigger(changeEvent);\n\n          if (this.tooltip) {\n            tooltiphtml = \"\";\n\n            for (i = 0; i < spcount; i++) {\n              sp = splist[i];\n              tooltiphtml += sp.getCurrentRegionTooltip();\n            }\n\n            this.tooltip.setContent(tooltiphtml);\n          }\n\n          if (!this.disableHighlight) {\n            this.canvas.render();\n          }\n        }\n\n        if (result === null) {\n          this.mouseleave();\n        }\n      }\n    });\n    Tooltip = createClass({\n      sizeStyle: \"position: static !important;\" + \"display: block !important;\" + \"visibility: hidden !important;\" + \"float: left !important;\",\n      init: function (options) {\n        var tooltipClassname = options.get(\"tooltipClassname\", \"jqstooltip\"),\n            sizetipStyle = this.sizeStyle,\n            offset;\n        this.container = options.get(\"tooltipContainer\") || document.body;\n        this.tooltipOffsetX = options.get(\"tooltipOffsetX\", 10);\n        this.tooltipOffsetY = options.get(\"tooltipOffsetY\", 12);\n        $(\"#jqssizetip\").remove();\n        $(\"#jqstooltip\").remove();\n        this.sizetip = $(\"<div/>\", {\n          id: \"jqssizetip\",\n          style: sizetipStyle,\n          \"class\": tooltipClassname\n        });\n        this.tooltip = $(\"<div/>\", {\n          id: \"jqstooltip\",\n          \"class\": tooltipClassname\n        }).appendTo(this.container);\n        offset = this.tooltip.offset();\n        this.offsetLeft = offset.left;\n        this.offsetTop = offset.top;\n        this.hidden = true;\n        $(window).unbind(\"resize.jqs scroll.jqs\");\n        $(window).bind(\"resize.jqs scroll.jqs\", $.proxy(this.updateWindowDims, this));\n        this.updateWindowDims();\n      },\n      updateWindowDims: function () {\n        this.scrollTop = $(window).scrollTop();\n        this.scrollLeft = $(window).scrollLeft();\n        this.scrollRight = this.scrollLeft + $(window).width();\n        this.updatePosition();\n      },\n      getSize: function (content) {\n        this.sizetip.html(content).appendTo(this.container);\n        this.width = this.sizetip.width() + 1;\n        this.height = this.sizetip.height();\n        this.sizetip.remove();\n      },\n      setContent: function (content) {\n        if (!content) {\n          this.tooltip.css(\"visibility\", \"hidden\");\n          this.hidden = true;\n          return;\n        }\n\n        this.getSize(content);\n        this.tooltip.html(content).css({\n          width: this.width,\n          height: this.height,\n          visibility: \"visible\"\n        });\n\n        if (this.hidden) {\n          this.hidden = false;\n          this.updatePosition();\n        }\n      },\n      updatePosition: function (x, y) {\n        if (x === undefined) {\n          if (this.mousex === undefined) {\n            return;\n          }\n\n          x = this.mousex - this.offsetLeft;\n          y = this.mousey - this.offsetTop;\n        } else {\n          this.mousex = x = x - this.offsetLeft;\n          this.mousey = y = y - this.offsetTop;\n        }\n\n        if (!this.height || !this.width || this.hidden) {\n          return;\n        }\n\n        y -= this.height + this.tooltipOffsetY;\n        x += this.tooltipOffsetX;\n\n        if (y < this.scrollTop) {\n          y = this.scrollTop;\n        }\n\n        if (x < this.scrollLeft) {\n          x = this.scrollLeft;\n        } else if (x + this.width > this.scrollRight) {\n          x = this.scrollRight - this.width;\n        }\n\n        this.tooltip.css({\n          left: x,\n          top: y\n        });\n      },\n      remove: function () {\n        this.tooltip.remove();\n        this.sizetip.remove();\n        this.sizetip = this.tooltip = undefined;\n        $(window).unbind(\"resize.jqs scroll.jqs\");\n      }\n    });\n\n    initStyles = function () {\n      addCSS(defaultStyles);\n    };\n\n    $(initStyles);\n    pending = [];\n\n    $.fn.sparkline = function (userValues, userOptions) {\n      return this.each(function () {\n        var options = new $.fn.sparkline.options(this, userOptions),\n            $this = $(this),\n            render,\n            i;\n\n        render = function () {\n          var values, width, height, tmp, mhandler, sp, vals;\n\n          if (userValues === \"html\" || userValues === undefined) {\n            vals = this.getAttribute(options.get(\"tagValuesAttribute\"));\n\n            if (vals === undefined || vals === null) {\n              vals = $this.html();\n            }\n\n            values = vals.replace(/(^\\s*<!--)|(-->\\s*$)|\\s+/g, \"\").split(\",\");\n          } else {\n            values = userValues;\n          }\n\n          width = options.get(\"width\") === \"auto\" ? values.length * options.get(\"defaultPixelsPerValue\") : options.get(\"width\");\n\n          if (options.get(\"height\") === \"auto\") {\n            if (!options.get(\"composite\") || !$.data(this, \"_jqs_vcanvas\")) {\n              tmp = document.createElement(\"span\");\n              tmp.innerHTML = \"a\";\n              $this.html(tmp);\n              height = $(tmp).innerHeight() || $(tmp).height();\n              $(tmp).remove();\n              tmp = null;\n            }\n          } else {\n            height = options.get(\"height\");\n          }\n\n          if (!options.get(\"disableInteraction\")) {\n            mhandler = $.data(this, \"_jqs_mhandler\");\n\n            if (!mhandler) {\n              mhandler = new MouseHandler(this, options);\n              $.data(this, \"_jqs_mhandler\", mhandler);\n            } else if (!options.get(\"composite\")) {\n              mhandler.reset();\n            }\n          } else {\n            mhandler = false;\n          }\n\n          if (options.get(\"composite\") && !$.data(this, \"_jqs_vcanvas\")) {\n            if (!$.data(this, \"_jqs_errnotify\")) {\n              alert(\"Attempted to attach a composite sparkline to an element with no existing sparkline\");\n              $.data(this, \"_jqs_errnotify\", true);\n            }\n\n            return;\n          }\n\n          sp = new $.fn.sparkline[options.get(\"type\")](this, values, options, width, height);\n          sp.render();\n\n          if (mhandler) {\n            mhandler.registerSparkline(sp);\n          }\n        };\n\n        if ($(this).html() && !options.get(\"disableHiddenCheck\") && $(this).is(\":hidden\") || !$(this).parents(\"body\").length) {\n          if (!options.get(\"composite\") && $.data(this, \"_jqs_pending\")) {\n            for (i = pending.length; i; i--) {\n              if (pending[i - 1][0] == this) {\n                pending.splice(i - 1, 1);\n              }\n            }\n          }\n\n          pending.push([this, render]);\n          $.data(this, \"_jqs_pending\", true);\n        } else {\n          render.call(this);\n        }\n      });\n    };\n\n    $.fn.sparkline.defaults = getDefaults();\n\n    $.sparkline_display_visible = function () {\n      var el, i, pl;\n      var done = [];\n\n      for (i = 0, pl = pending.length; i < pl; i++) {\n        el = pending[i][0];\n\n        if ($(el).is(\":visible\") && !$(el).parents().is(\":hidden\")) {\n          pending[i][1].call(el);\n          $.data(pending[i][0], \"_jqs_pending\", false);\n          done.push(i);\n        } else if (!$(el).closest(\"html\").length && !$.data(el, \"_jqs_pending\")) {\n          $.data(pending[i][0], \"_jqs_pending\", false);\n          done.push(i);\n        }\n      }\n\n      for (i = done.length; i; i--) {\n        pending.splice(done[i - 1], 1);\n      }\n    };\n\n    $.fn.sparkline.options = createClass({\n      init: function (tag, userOptions) {\n        var extendedOptions, defaults, base, tagOptionType;\n        this.userOptions = userOptions = userOptions || {};\n        this.tag = tag;\n        this.tagValCache = {};\n        defaults = $.fn.sparkline.defaults;\n        base = defaults.common;\n        this.tagOptionsPrefix = userOptions.enableTagOptions && (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);\n        tagOptionType = this.getTagSetting(\"type\");\n\n        if (tagOptionType === UNSET_OPTION) {\n          extendedOptions = defaults[userOptions.type || base.type];\n        } else {\n          extendedOptions = defaults[tagOptionType];\n        }\n\n        this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);\n      },\n      getTagSetting: function (key) {\n        var prefix = this.tagOptionsPrefix,\n            val,\n            i,\n            pairs,\n            keyval;\n\n        if (prefix === false || prefix === undefined) {\n          return UNSET_OPTION;\n        }\n\n        if (this.tagValCache.hasOwnProperty(key)) {\n          val = this.tagValCache.key;\n        } else {\n          val = this.tag.getAttribute(prefix + key);\n\n          if (val === undefined || val === null) {\n            val = UNSET_OPTION;\n          } else if (val.substr(0, 1) === \"[\") {\n            val = val.substr(1, val.length - 2).split(\",\");\n\n            for (i = val.length; i--;) {\n              val[i] = normalizeValue(val[i].replace(/(^\\s*)|(\\s*$)/g, \"\"));\n            }\n          } else if (val.substr(0, 1) === \"{\") {\n            pairs = val.substr(1, val.length - 2).split(\",\");\n            val = {};\n\n            for (i = pairs.length; i--;) {\n              keyval = pairs[i].split(\":\", 2);\n              val[keyval[0].replace(/(^\\s*)|(\\s*$)/g, \"\")] = normalizeValue(keyval[1].replace(/(^\\s*)|(\\s*$)/g, \"\"));\n            }\n          } else {\n            val = normalizeValue(val);\n          }\n\n          this.tagValCache.key = val;\n        }\n\n        return val;\n      },\n      get: function (key, defaultval) {\n        var tagOption = this.getTagSetting(key),\n            result;\n\n        if (tagOption !== UNSET_OPTION) {\n          return tagOption;\n        }\n\n        return (result = this.mergedOptions[key]) === undefined ? defaultval : result;\n      }\n    });\n    $.fn.sparkline._base = createClass({\n      disabled: false,\n      init: function (el, values, options, width, height) {\n        this.el = el;\n        this.$el = $(el);\n        this.values = values;\n        this.options = options;\n        this.width = width;\n        this.height = height;\n        this.currentRegion = undefined;\n      },\n      initTarget: function () {\n        var interactive = !this.options.get(\"disableInteraction\");\n\n        if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get(\"composite\"), interactive))) {\n          this.disabled = true;\n        } else {\n          this.canvasWidth = this.target.pixelWidth;\n          this.canvasHeight = this.target.pixelHeight;\n        }\n      },\n      render: function () {\n        if (this.disabled) {\n          this.el.innerHTML = \"\";\n          return false;\n        }\n\n        return true;\n      },\n      getRegion: function (x, y) {},\n      setRegionHighlight: function (el, x, y) {\n        var currentRegion = this.currentRegion,\n            highlightEnabled = !this.options.get(\"disableHighlight\"),\n            newRegion;\n\n        if (x > this.canvasWidth || y > this.canvasHeight || x < 0 || y < 0) {\n          return null;\n        }\n\n        newRegion = this.getRegion(el, x, y);\n\n        if (currentRegion !== newRegion) {\n          if (currentRegion !== undefined && highlightEnabled) {\n            this.removeHighlight();\n          }\n\n          this.currentRegion = newRegion;\n\n          if (newRegion !== undefined && highlightEnabled) {\n            this.renderHighlight();\n          }\n\n          return true;\n        }\n\n        return false;\n      },\n      clearRegionHighlight: function () {\n        if (this.currentRegion !== undefined) {\n          this.removeHighlight();\n          this.currentRegion = undefined;\n          return true;\n        }\n\n        return false;\n      },\n      renderHighlight: function () {\n        this.changeHighlight(true);\n      },\n      removeHighlight: function () {\n        this.changeHighlight(false);\n      },\n      changeHighlight: function (highlight) {},\n      getCurrentRegionTooltip: function () {\n        var options = this.options,\n            header = \"\",\n            entries = [],\n            fields,\n            formats,\n            formatlen,\n            fclass,\n            text,\n            i,\n            showFields,\n            showFieldsKey,\n            newFields,\n            fv,\n            formatter,\n            format,\n            fieldlen,\n            j;\n\n        if (this.currentRegion === undefined) {\n          return \"\";\n        }\n\n        fields = this.getCurrentRegionFields();\n        formatter = options.get(\"tooltipFormatter\");\n\n        if (formatter) {\n          return formatter(this, options, fields);\n        }\n\n        if (options.get(\"tooltipChartTitle\")) {\n          header += '<div class=\"jqs jqstitle\">' + options.get(\"tooltipChartTitle\") + \"</div>\\n\";\n        }\n\n        formats = this.options.get(\"tooltipFormat\");\n\n        if (!formats) {\n          return \"\";\n        }\n\n        if (!$.isArray(formats)) {\n          formats = [formats];\n        }\n\n        if (!$.isArray(fields)) {\n          fields = [fields];\n        }\n\n        showFields = this.options.get(\"tooltipFormatFieldlist\");\n        showFieldsKey = this.options.get(\"tooltipFormatFieldlistKey\");\n\n        if (showFields && showFieldsKey) {\n          newFields = [];\n\n          for (i = fields.length; i--;) {\n            fv = fields[i][showFieldsKey];\n\n            if ((j = $.inArray(fv, showFields)) != -1) {\n              newFields[j] = fields[i];\n            }\n          }\n\n          fields = newFields;\n        }\n\n        formatlen = formats.length;\n        fieldlen = fields.length;\n\n        for (i = 0; i < formatlen; i++) {\n          format = formats[i];\n\n          if (typeof format === \"string\") {\n            format = new SPFormat(format);\n          }\n\n          fclass = format.fclass || \"jqsfield\";\n\n          for (j = 0; j < fieldlen; j++) {\n            if (!fields[j].isNull || !options.get(\"tooltipSkipNull\")) {\n              $.extend(fields[j], {\n                prefix: options.get(\"tooltipPrefix\"),\n                suffix: options.get(\"tooltipSuffix\")\n              });\n              text = format.render(fields[j], options.get(\"tooltipValueLookups\"), options);\n              entries.push('<div class=\"' + fclass + '\">' + text + \"</div>\");\n            }\n          }\n        }\n\n        if (entries.length) {\n          return header + entries.join(\"\\n\");\n        }\n\n        return \"\";\n      },\n      getCurrentRegionFields: function () {},\n      calcHighlightColor: function (color, options) {\n        var highlightColor = options.get(\"highlightColor\"),\n            lighten = options.get(\"highlightLighten\"),\n            parse,\n            mult,\n            rgbnew,\n            i;\n\n        if (highlightColor) {\n          return highlightColor;\n        }\n\n        if (lighten) {\n          parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);\n\n          if (parse) {\n            rgbnew = [];\n            mult = color.length === 4 ? 16 : 1;\n\n            for (i = 0; i < 3; i++) {\n              rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);\n            }\n\n            return \"rgb(\" + rgbnew.join(\",\") + \")\";\n          }\n        }\n\n        return color;\n      }\n    });\n    barHighlightMixin = {\n      changeHighlight: function (highlight) {\n        var currentRegion = this.currentRegion,\n            target = this.target,\n            shapeids = this.regionShapes[currentRegion],\n            newShapes;\n\n        if (shapeids) {\n          newShapes = this.renderRegion(currentRegion, highlight);\n\n          if ($.isArray(newShapes) || $.isArray(shapeids)) {\n            target.replaceWithShapes(shapeids, newShapes);\n            this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {\n              return newShape.id;\n            });\n          } else {\n            target.replaceWithShape(shapeids, newShapes);\n            this.regionShapes[currentRegion] = newShapes.id;\n          }\n        }\n      },\n      render: function () {\n        var values = this.values,\n            target = this.target,\n            regionShapes = this.regionShapes,\n            shapes,\n            ids,\n            i,\n            j;\n\n        if (!this.cls._super.render.call(this)) {\n          return;\n        }\n\n        for (i = values.length; i--;) {\n          shapes = this.renderRegion(i);\n\n          if (shapes) {\n            if ($.isArray(shapes)) {\n              ids = [];\n\n              for (j = shapes.length; j--;) {\n                shapes[j].append();\n                ids.push(shapes[j].id);\n              }\n\n              regionShapes[i] = ids;\n            } else {\n              shapes.append();\n              regionShapes[i] = shapes.id;\n            }\n          } else {\n            regionShapes[i] = null;\n          }\n        }\n\n        target.render();\n      }\n    };\n    $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {\n      type: \"line\",\n      init: function (el, values, options, width, height) {\n        line._super.init.call(this, el, values, options, width, height);\n\n        this.vertices = [];\n        this.regionMap = [];\n        this.xvalues = [];\n        this.yvalues = [];\n        this.yminmax = [];\n        this.hightlightSpotId = null;\n        this.lastShapeId = null;\n        this.initTarget();\n      },\n      getRegion: function (el, x, y) {\n        var i,\n            regionMap = this.regionMap;\n\n        for (i = regionMap.length; i--;) {\n          if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {\n            return regionMap[i][2];\n          }\n        }\n\n        return undefined;\n      },\n      getCurrentRegionFields: function () {\n        var currentRegion = this.currentRegion;\n        return {\n          isNull: this.yvalues[currentRegion] === null,\n          x: this.xvalues[currentRegion],\n          y: this.yvalues[currentRegion],\n          color: this.options.get(\"lineColor\"),\n          fillColor: this.options.get(\"fillColor\"),\n          offset: currentRegion\n        };\n      },\n      renderHighlight: function () {\n        var currentRegion = this.currentRegion,\n            target = this.target,\n            vertex = this.vertices[currentRegion],\n            options = this.options,\n            spotRadius = options.get(\"spotRadius\"),\n            highlightSpotColor = options.get(\"highlightSpotColor\"),\n            highlightLineColor = options.get(\"highlightLineColor\"),\n            highlightSpot,\n            highlightLine;\n\n        if (!vertex) {\n          return;\n        }\n\n        if (spotRadius && highlightSpotColor) {\n          highlightSpot = target.drawCircle(vertex[0], vertex[1], spotRadius, undefined, highlightSpotColor);\n          this.highlightSpotId = highlightSpot.id;\n          target.insertAfterShape(this.lastShapeId, highlightSpot);\n        }\n\n        if (highlightLineColor) {\n          highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0], this.canvasTop + this.canvasHeight, highlightLineColor);\n          this.highlightLineId = highlightLine.id;\n          target.insertAfterShape(this.lastShapeId, highlightLine);\n        }\n      },\n      removeHighlight: function () {\n        var target = this.target;\n\n        if (this.highlightSpotId) {\n          target.removeShapeId(this.highlightSpotId);\n          this.highlightSpotId = null;\n        }\n\n        if (this.highlightLineId) {\n          target.removeShapeId(this.highlightLineId);\n          this.highlightLineId = null;\n        }\n      },\n      scanValues: function () {\n        var values = this.values,\n            valcount = values.length,\n            xvalues = this.xvalues,\n            yvalues = this.yvalues,\n            yminmax = this.yminmax,\n            i,\n            val,\n            isStr,\n            isArray,\n            sp;\n\n        for (i = 0; i < valcount; i++) {\n          val = values[i];\n          isStr = typeof values[i] === \"string\";\n          isArray = typeof values[i] === \"object\" && values[i] instanceof Array;\n          sp = isStr && values[i].split(\":\");\n\n          if (isStr && sp.length === 2) {\n            xvalues.push(Number(sp[0]));\n            yvalues.push(Number(sp[1]));\n            yminmax.push(Number(sp[1]));\n          } else if (isArray) {\n            xvalues.push(val[0]);\n            yvalues.push(val[1]);\n            yminmax.push(val[1]);\n          } else {\n            xvalues.push(i);\n\n            if (values[i] === null || values[i] === \"null\") {\n              yvalues.push(null);\n            } else {\n              yvalues.push(Number(val));\n              yminmax.push(Number(val));\n            }\n          }\n        }\n\n        if (this.options.get(\"xvalues\")) {\n          xvalues = this.options.get(\"xvalues\");\n        }\n\n        this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);\n        this.miny = this.minyorg = Math.min.apply(Math, yminmax);\n        this.maxx = Math.max.apply(Math, xvalues);\n        this.minx = Math.min.apply(Math, xvalues);\n        this.xvalues = xvalues;\n        this.yvalues = yvalues;\n        this.yminmax = yminmax;\n      },\n      processRangeOptions: function () {\n        var options = this.options,\n            normalRangeMin = options.get(\"normalRangeMin\"),\n            normalRangeMax = options.get(\"normalRangeMax\");\n\n        if (normalRangeMin !== undefined) {\n          if (normalRangeMin < this.miny) {\n            this.miny = normalRangeMin;\n          }\n\n          if (normalRangeMax > this.maxy) {\n            this.maxy = normalRangeMax;\n          }\n        }\n\n        if (options.get(\"chartRangeMin\") !== undefined && (options.get(\"chartRangeClip\") || options.get(\"chartRangeMin\") < this.miny)) {\n          this.miny = options.get(\"chartRangeMin\");\n        }\n\n        if (options.get(\"chartRangeMax\") !== undefined && (options.get(\"chartRangeClip\") || options.get(\"chartRangeMax\") > this.maxy)) {\n          this.maxy = options.get(\"chartRangeMax\");\n        }\n\n        if (options.get(\"chartRangeMinX\") !== undefined && (options.get(\"chartRangeClipX\") || options.get(\"chartRangeMinX\") < this.minx)) {\n          this.minx = options.get(\"chartRangeMinX\");\n        }\n\n        if (options.get(\"chartRangeMaxX\") !== undefined && (options.get(\"chartRangeClipX\") || options.get(\"chartRangeMaxX\") > this.maxx)) {\n          this.maxx = options.get(\"chartRangeMaxX\");\n        }\n      },\n      drawNormalRange: function (canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {\n        var normalRangeMin = this.options.get(\"normalRangeMin\"),\n            normalRangeMax = this.options.get(\"normalRangeMax\"),\n            ytop = canvasTop + Math.round(canvasHeight - canvasHeight * ((normalRangeMax - this.miny) / rangey)),\n            height = Math.round(canvasHeight * (normalRangeMax - normalRangeMin) / rangey);\n        this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get(\"normalRangeColor\")).append();\n      },\n      render: function () {\n        var options = this.options,\n            target = this.target,\n            canvasWidth = this.canvasWidth,\n            canvasHeight = this.canvasHeight,\n            vertices = this.vertices,\n            spotRadius = options.get(\"spotRadius\"),\n            regionMap = this.regionMap,\n            rangex,\n            rangey,\n            yvallast,\n            canvasTop,\n            canvasLeft,\n            vertex,\n            path,\n            paths,\n            x,\n            y,\n            xnext,\n            xpos,\n            xposnext,\n            last,\n            next,\n            yvalcount,\n            lineShapes,\n            fillShapes,\n            plen,\n            valueSpots,\n            hlSpotsEnabled,\n            color,\n            xvalues,\n            yvalues,\n            i;\n\n        if (!line._super.render.call(this)) {\n          return;\n        }\n\n        this.scanValues();\n        this.processRangeOptions();\n        xvalues = this.xvalues;\n        yvalues = this.yvalues;\n\n        if (!this.yminmax.length || this.yvalues.length < 2) {\n          return;\n        }\n\n        canvasTop = canvasLeft = 0;\n        rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;\n        rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;\n        yvallast = this.yvalues.length - 1;\n\n        if (spotRadius && (canvasWidth < spotRadius * 4 || canvasHeight < spotRadius * 4)) {\n          spotRadius = 0;\n        }\n\n        if (spotRadius) {\n          hlSpotsEnabled = options.get(\"highlightSpotColor\") && !options.get(\"disableInteraction\");\n\n          if (hlSpotsEnabled || options.get(\"minSpotColor\") || options.get(\"spotColor\") && yvalues[yvallast] === this.miny) {\n            canvasHeight -= Math.ceil(spotRadius);\n          }\n\n          if (hlSpotsEnabled || options.get(\"maxSpotColor\") || options.get(\"spotColor\") && yvalues[yvallast] === this.maxy) {\n            canvasHeight -= Math.ceil(spotRadius);\n            canvasTop += Math.ceil(spotRadius);\n          }\n\n          if (hlSpotsEnabled || (options.get(\"minSpotColor\") || options.get(\"maxSpotColor\")) && (yvalues[0] === this.miny || yvalues[0] === this.maxy)) {\n            canvasLeft += Math.ceil(spotRadius);\n            canvasWidth -= Math.ceil(spotRadius);\n          }\n\n          if (hlSpotsEnabled || options.get(\"spotColor\") || options.get(\"minSpotColor\") || options.get(\"maxSpotColor\") && (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy)) {\n            canvasWidth -= Math.ceil(spotRadius);\n          }\n        }\n\n        canvasHeight--;\n\n        if (options.get(\"normalRangeMin\") !== undefined && !options.get(\"drawNormalOnTop\")) {\n          this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);\n        }\n\n        path = [];\n        paths = [path];\n        last = next = null;\n        yvalcount = yvalues.length;\n\n        for (i = 0; i < yvalcount; i++) {\n          x = xvalues[i];\n          xnext = xvalues[i + 1];\n          y = yvalues[i];\n          xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));\n          xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;\n          next = xpos + (xposnext - xpos) / 2;\n          regionMap[i] = [last || 0, next, i];\n          last = next;\n\n          if (y === null) {\n            if (i) {\n              if (yvalues[i - 1] !== null) {\n                path = [];\n                paths.push(path);\n              }\n\n              vertices.push(null);\n            }\n          } else {\n            if (y < this.miny) {\n              y = this.miny;\n            }\n\n            if (y > this.maxy) {\n              y = this.maxy;\n            }\n\n            if (!path.length) {\n              path.push([xpos, canvasTop + canvasHeight]);\n            }\n\n            vertex = [xpos, canvasTop + Math.round(canvasHeight - canvasHeight * ((y - this.miny) / rangey))];\n            path.push(vertex);\n            vertices.push(vertex);\n          }\n        }\n\n        lineShapes = [];\n        fillShapes = [];\n        plen = paths.length;\n\n        for (i = 0; i < plen; i++) {\n          path = paths[i];\n\n          if (path.length) {\n            if (options.get(\"fillColor\")) {\n              path.push([path[path.length - 1][0], canvasTop + canvasHeight]);\n              fillShapes.push(path.slice(0));\n              path.pop();\n            }\n\n            if (path.length > 2) {\n              path[0] = [path[0][0], path[1][1]];\n            }\n\n            lineShapes.push(path);\n          }\n        }\n\n        plen = fillShapes.length;\n\n        for (i = 0; i < plen; i++) {\n          target.drawShape(fillShapes[i], options.get(\"fillColor\"), options.get(\"fillColor\")).append();\n        }\n\n        if (options.get(\"normalRangeMin\") !== undefined && options.get(\"drawNormalOnTop\")) {\n          this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);\n        }\n\n        plen = lineShapes.length;\n\n        for (i = 0; i < plen; i++) {\n          target.drawShape(lineShapes[i], options.get(\"lineColor\"), undefined, options.get(\"lineWidth\")).append();\n        }\n\n        if (spotRadius && options.get(\"valueSpots\")) {\n          valueSpots = options.get(\"valueSpots\");\n\n          if (valueSpots.get === undefined) {\n            valueSpots = new RangeMap(valueSpots);\n          }\n\n          for (i = 0; i < yvalcount; i++) {\n            color = valueSpots.get(yvalues[i]);\n\n            if (color) {\n              target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[i] - this.miny) / rangey)), spotRadius, undefined, color).append();\n            }\n          }\n        }\n\n        if (spotRadius && options.get(\"spotColor\") && yvalues[yvallast] !== null) {\n          target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[yvallast] - this.miny) / rangey)), spotRadius, undefined, options.get(\"spotColor\")).append();\n        }\n\n        if (this.maxy !== this.minyorg) {\n          if (spotRadius && options.get(\"minSpotColor\")) {\n            x = xvalues[$.inArray(this.minyorg, yvalues)];\n            target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.minyorg - this.miny) / rangey)), spotRadius, undefined, options.get(\"minSpotColor\")).append();\n          }\n\n          if (spotRadius && options.get(\"maxSpotColor\")) {\n            x = xvalues[$.inArray(this.maxyorg, yvalues)];\n            target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.maxyorg - this.miny) / rangey)), spotRadius, undefined, options.get(\"maxSpotColor\")).append();\n          }\n        }\n\n        this.lastShapeId = target.getLastShapeId();\n        this.canvasTop = canvasTop;\n        target.render();\n      }\n    });\n    $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {\n      type: \"bar\",\n      init: function (el, values, options, width, height) {\n        var barWidth = parseInt(options.get(\"barWidth\"), 10),\n            barSpacing = parseInt(options.get(\"barSpacing\"), 10),\n            chartRangeMin = options.get(\"chartRangeMin\"),\n            chartRangeMax = options.get(\"chartRangeMax\"),\n            chartRangeClip = options.get(\"chartRangeClip\"),\n            stackMin = Infinity,\n            stackMax = -Infinity,\n            isStackString,\n            groupMin,\n            groupMax,\n            stackRanges,\n            numValues,\n            i,\n            vlen,\n            range,\n            zeroAxis,\n            xaxisOffset,\n            min,\n            max,\n            clipMin,\n            clipMax,\n            stacked,\n            vlist,\n            j,\n            slen,\n            svals,\n            val,\n            yoffset,\n            yMaxCalc,\n            canvasHeightEf;\n\n        bar._super.init.call(this, el, values, options, width, height);\n\n        for (i = 0, vlen = values.length; i < vlen; i++) {\n          val = values[i];\n          isStackString = typeof val === \"string\" && val.indexOf(\":\") > -1;\n\n          if (isStackString || $.isArray(val)) {\n            stacked = true;\n\n            if (isStackString) {\n              val = values[i] = normalizeValues(val.split(\":\"));\n            }\n\n            val = remove(val, null);\n            groupMin = Math.min.apply(Math, val);\n            groupMax = Math.max.apply(Math, val);\n\n            if (groupMin < stackMin) {\n              stackMin = groupMin;\n            }\n\n            if (groupMax > stackMax) {\n              stackMax = groupMax;\n            }\n          }\n        }\n\n        this.stacked = stacked;\n        this.regionShapes = {};\n        this.barWidth = barWidth;\n        this.barSpacing = barSpacing;\n        this.totalBarWidth = barWidth + barSpacing;\n        this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;\n        this.initTarget();\n\n        if (chartRangeClip) {\n          clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;\n          clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;\n        }\n\n        numValues = [];\n        stackRanges = stacked ? [] : numValues;\n        var stackTotals = [];\n        var stackRangesNeg = [];\n\n        for (i = 0, vlen = values.length; i < vlen; i++) {\n          if (stacked) {\n            vlist = values[i];\n            values[i] = svals = [];\n            stackTotals[i] = 0;\n            stackRanges[i] = stackRangesNeg[i] = 0;\n\n            for (j = 0, slen = vlist.length; j < slen; j++) {\n              val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];\n\n              if (val !== null) {\n                if (val > 0) {\n                  stackTotals[i] += val;\n                }\n\n                if (stackMin < 0 && stackMax > 0) {\n                  if (val < 0) {\n                    stackRangesNeg[i] += Math.abs(val);\n                  } else {\n                    stackRanges[i] += val;\n                  }\n                } else {\n                  stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));\n                }\n\n                numValues.push(val);\n              }\n            }\n          } else {\n            val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];\n            val = values[i] = normalizeValue(val);\n\n            if (val !== null) {\n              numValues.push(val);\n            }\n          }\n        }\n\n        this.max = max = Math.max.apply(Math, numValues);\n        this.min = min = Math.min.apply(Math, numValues);\n        this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;\n        this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;\n\n        if (options.get(\"chartRangeMin\") !== undefined && (options.get(\"chartRangeClip\") || options.get(\"chartRangeMin\") < min)) {\n          min = options.get(\"chartRangeMin\");\n        }\n\n        if (options.get(\"chartRangeMax\") !== undefined && (options.get(\"chartRangeClip\") || options.get(\"chartRangeMax\") > max)) {\n          max = options.get(\"chartRangeMax\");\n        }\n\n        this.zeroAxis = zeroAxis = options.get(\"zeroAxis\", true);\n\n        if (min <= 0 && max >= 0 && zeroAxis) {\n          xaxisOffset = 0;\n        } else if (zeroAxis == false) {\n          xaxisOffset = min;\n        } else if (min > 0) {\n          xaxisOffset = min;\n        } else {\n          xaxisOffset = max;\n        }\n\n        this.xaxisOffset = xaxisOffset;\n        range = stacked ? Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg) : max - min;\n        this.canvasHeightEf = zeroAxis && min < 0 ? this.canvasHeight - 2 : this.canvasHeight - 1;\n\n        if (min < xaxisOffset) {\n          yMaxCalc = stacked && max >= 0 ? stackMax : max;\n          yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;\n\n          if (yoffset !== Math.ceil(yoffset)) {\n            this.canvasHeightEf -= 2;\n            yoffset = Math.ceil(yoffset);\n          }\n        } else {\n          yoffset = this.canvasHeight;\n        }\n\n        this.yoffset = yoffset;\n\n        if ($.isArray(options.get(\"colorMap\"))) {\n          this.colorMapByIndex = options.get(\"colorMap\");\n          this.colorMapByValue = null;\n        } else {\n          this.colorMapByIndex = null;\n          this.colorMapByValue = options.get(\"colorMap\");\n\n          if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n            this.colorMapByValue = new RangeMap(this.colorMapByValue);\n          }\n        }\n\n        this.range = range;\n      },\n      getRegion: function (el, x, y) {\n        var result = Math.floor(x / this.totalBarWidth);\n        return result < 0 || result >= this.values.length ? undefined : result;\n      },\n      getCurrentRegionFields: function () {\n        var currentRegion = this.currentRegion,\n            values = ensureArray(this.values[currentRegion]),\n            result = [],\n            value,\n            i;\n\n        for (i = values.length; i--;) {\n          value = values[i];\n          result.push({\n            isNull: value === null,\n            value: value,\n            color: this.calcColor(i, value, currentRegion),\n            offset: currentRegion\n          });\n        }\n\n        return result;\n      },\n      calcColor: function (stacknum, value, valuenum) {\n        var colorMapByIndex = this.colorMapByIndex,\n            colorMapByValue = this.colorMapByValue,\n            options = this.options,\n            color,\n            newColor;\n\n        if (this.stacked) {\n          color = options.get(\"stackedBarColor\");\n        } else {\n          color = value < 0 ? options.get(\"negBarColor\") : options.get(\"barColor\");\n        }\n\n        if (value === 0 && options.get(\"zeroColor\") !== undefined) {\n          color = options.get(\"zeroColor\");\n        }\n\n        if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n          color = newColor;\n        } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n          color = colorMapByIndex[valuenum];\n        }\n\n        return $.isArray(color) ? color[stacknum % color.length] : color;\n      },\n      renderRegion: function (valuenum, highlight) {\n        var vals = this.values[valuenum],\n            options = this.options,\n            xaxisOffset = this.xaxisOffset,\n            result = [],\n            range = this.range,\n            stacked = this.stacked,\n            target = this.target,\n            x = valuenum * this.totalBarWidth,\n            canvasHeightEf = this.canvasHeightEf,\n            yoffset = this.yoffset,\n            y,\n            height,\n            color,\n            isNull,\n            yoffsetNeg,\n            i,\n            valcount,\n            val,\n            minPlotted,\n            allMin;\n        vals = $.isArray(vals) ? vals : [vals];\n        valcount = vals.length;\n        val = vals[0];\n        isNull = all(null, vals);\n        allMin = all(xaxisOffset, vals, true);\n\n        if (isNull) {\n          if (options.get(\"nullColor\")) {\n            color = highlight ? options.get(\"nullColor\") : this.calcHighlightColor(options.get(\"nullColor\"), options);\n            y = yoffset > 0 ? yoffset - 1 : yoffset;\n            return target.drawRect(x, y, this.barWidth - 1, 0, color, color);\n          } else {\n            return undefined;\n          }\n        }\n\n        yoffsetNeg = yoffset;\n\n        for (i = 0; i < valcount; i++) {\n          val = vals[i];\n\n          if (stacked && val === xaxisOffset) {\n            if (!allMin || minPlotted) {\n              continue;\n            }\n\n            minPlotted = true;\n          }\n\n          if (range > 0) {\n            height = Math.floor(canvasHeightEf * (Math.abs(val - xaxisOffset) / range)) + 1;\n          } else {\n            height = 1;\n          }\n\n          if (val < xaxisOffset || val === xaxisOffset && yoffset === 0) {\n            y = yoffsetNeg;\n            yoffsetNeg += height;\n          } else {\n            y = yoffset - height;\n            yoffset -= height;\n          }\n\n          color = this.calcColor(i, val, valuenum);\n\n          if (highlight) {\n            color = this.calcHighlightColor(color, options);\n          }\n\n          result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));\n        }\n\n        if (result.length === 1) {\n          return result[0];\n        }\n\n        return result;\n      }\n    });\n    $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {\n      type: \"tristate\",\n      init: function (el, values, options, width, height) {\n        var barWidth = parseInt(options.get(\"barWidth\"), 10),\n            barSpacing = parseInt(options.get(\"barSpacing\"), 10);\n\n        tristate._super.init.call(this, el, values, options, width, height);\n\n        this.regionShapes = {};\n        this.barWidth = barWidth;\n        this.barSpacing = barSpacing;\n        this.totalBarWidth = barWidth + barSpacing;\n        this.values = $.map(values, Number);\n        this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;\n\n        if ($.isArray(options.get(\"colorMap\"))) {\n          this.colorMapByIndex = options.get(\"colorMap\");\n          this.colorMapByValue = null;\n        } else {\n          this.colorMapByIndex = null;\n          this.colorMapByValue = options.get(\"colorMap\");\n\n          if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n            this.colorMapByValue = new RangeMap(this.colorMapByValue);\n          }\n        }\n\n        this.initTarget();\n      },\n      getRegion: function (el, x, y) {\n        return Math.floor(x / this.totalBarWidth);\n      },\n      getCurrentRegionFields: function () {\n        var currentRegion = this.currentRegion;\n        return {\n          isNull: this.values[currentRegion] === undefined,\n          value: this.values[currentRegion],\n          color: this.calcColor(this.values[currentRegion], currentRegion),\n          offset: currentRegion\n        };\n      },\n      calcColor: function (value, valuenum) {\n        var values = this.values,\n            options = this.options,\n            colorMapByIndex = this.colorMapByIndex,\n            colorMapByValue = this.colorMapByValue,\n            color,\n            newColor;\n\n        if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n          color = newColor;\n        } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n          color = colorMapByIndex[valuenum];\n        } else if (values[valuenum] < 0) {\n          color = options.get(\"negBarColor\");\n        } else if (values[valuenum] > 0) {\n          color = options.get(\"posBarColor\");\n        } else {\n          color = options.get(\"zeroBarColor\");\n        }\n\n        return color;\n      },\n      renderRegion: function (valuenum, highlight) {\n        var values = this.values,\n            options = this.options,\n            target = this.target,\n            canvasHeight,\n            height,\n            halfHeight,\n            x,\n            y,\n            color;\n        canvasHeight = target.pixelHeight;\n        halfHeight = Math.round(canvasHeight / 2);\n        x = valuenum * this.totalBarWidth;\n\n        if (values[valuenum] < 0) {\n          y = halfHeight;\n          height = halfHeight - 1;\n        } else if (values[valuenum] > 0) {\n          y = 0;\n          height = halfHeight - 1;\n        } else {\n          y = halfHeight - 1;\n          height = 2;\n        }\n\n        color = this.calcColor(values[valuenum], valuenum);\n\n        if (color === null) {\n          return;\n        }\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, options);\n        }\n\n        return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);\n      }\n    });\n    $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {\n      type: \"discrete\",\n      init: function (el, values, options, width, height) {\n        discrete._super.init.call(this, el, values, options, width, height);\n\n        this.regionShapes = {};\n        this.values = values = $.map(values, Number);\n        this.min = Math.min.apply(Math, values);\n        this.max = Math.max.apply(Math, values);\n        this.range = this.max - this.min;\n        this.width = width = options.get(\"width\") === \"auto\" ? values.length * 2 : this.width;\n        this.interval = Math.floor(width / values.length);\n        this.itemWidth = width / values.length;\n\n        if (options.get(\"chartRangeMin\") !== undefined && (options.get(\"chartRangeClip\") || options.get(\"chartRangeMin\") < this.min)) {\n          this.min = options.get(\"chartRangeMin\");\n        }\n\n        if (options.get(\"chartRangeMax\") !== undefined && (options.get(\"chartRangeClip\") || options.get(\"chartRangeMax\") > this.max)) {\n          this.max = options.get(\"chartRangeMax\");\n        }\n\n        this.initTarget();\n\n        if (this.target) {\n          this.lineHeight = options.get(\"lineHeight\") === \"auto\" ? Math.round(this.canvasHeight * .3) : options.get(\"lineHeight\");\n        }\n      },\n      getRegion: function (el, x, y) {\n        return Math.floor(x / this.itemWidth);\n      },\n      getCurrentRegionFields: function () {\n        var currentRegion = this.currentRegion;\n        return {\n          isNull: this.values[currentRegion] === undefined,\n          value: this.values[currentRegion],\n          offset: currentRegion\n        };\n      },\n      renderRegion: function (valuenum, highlight) {\n        var values = this.values,\n            options = this.options,\n            min = this.min,\n            max = this.max,\n            range = this.range,\n            interval = this.interval,\n            target = this.target,\n            canvasHeight = this.canvasHeight,\n            lineHeight = this.lineHeight,\n            pheight = canvasHeight - lineHeight,\n            ytop,\n            val,\n            color,\n            x;\n        val = clipval(values[valuenum], min, max);\n        x = valuenum * interval;\n        ytop = Math.round(pheight - pheight * ((val - min) / range));\n        color = options.get(\"thresholdColor\") && val < options.get(\"thresholdValue\") ? options.get(\"thresholdColor\") : options.get(\"lineColor\");\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, options);\n        }\n\n        return target.drawLine(x, ytop, x, ytop + lineHeight, color);\n      }\n    });\n    $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {\n      type: \"bullet\",\n      init: function (el, values, options, width, height) {\n        var min, max, vals;\n\n        bullet._super.init.call(this, el, values, options, width, height);\n\n        this.values = values = normalizeValues(values);\n        vals = values.slice();\n        vals[0] = vals[0] === null ? vals[2] : vals[0];\n        vals[1] = values[1] === null ? vals[2] : vals[1];\n        min = Math.min.apply(Math, values);\n        max = Math.max.apply(Math, values);\n\n        if (options.get(\"base\") === undefined) {\n          min = min < 0 ? min : 0;\n        } else {\n          min = options.get(\"base\");\n        }\n\n        this.min = min;\n        this.max = max;\n        this.range = max - min;\n        this.shapes = {};\n        this.valueShapes = {};\n        this.regiondata = {};\n        this.width = width = options.get(\"width\") === \"auto\" ? \"4.0em\" : width;\n        this.target = this.$el.simpledraw(width, height, options.get(\"composite\"));\n\n        if (!values.length) {\n          this.disabled = true;\n        }\n\n        this.initTarget();\n      },\n      getRegion: function (el, x, y) {\n        var shapeid = this.target.getShapeAt(el, x, y);\n        return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;\n      },\n      getCurrentRegionFields: function () {\n        var currentRegion = this.currentRegion;\n        return {\n          fieldkey: currentRegion.substr(0, 1),\n          value: this.values[currentRegion.substr(1)],\n          region: currentRegion\n        };\n      },\n      changeHighlight: function (highlight) {\n        var currentRegion = this.currentRegion,\n            shapeid = this.valueShapes[currentRegion],\n            shape;\n        delete this.shapes[shapeid];\n\n        switch (currentRegion.substr(0, 1)) {\n          case \"r\":\n            shape = this.renderRange(currentRegion.substr(1), highlight);\n            break;\n\n          case \"p\":\n            shape = this.renderPerformance(highlight);\n            break;\n\n          case \"t\":\n            shape = this.renderTarget(highlight);\n            break;\n        }\n\n        this.valueShapes[currentRegion] = shape.id;\n        this.shapes[shape.id] = currentRegion;\n        this.target.replaceWithShape(shapeid, shape);\n      },\n      renderRange: function (rn, highlight) {\n        var rangeval = this.values[rn],\n            rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),\n            color = this.options.get(\"rangeColors\")[rn - 2];\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, this.options);\n        }\n\n        return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);\n      },\n      renderPerformance: function (highlight) {\n        var perfval = this.values[1],\n            perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),\n            color = this.options.get(\"performanceColor\");\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, this.options);\n        }\n\n        return this.target.drawRect(0, Math.round(this.canvasHeight * .3), perfwidth - 1, Math.round(this.canvasHeight * .4) - 1, color, color);\n      },\n      renderTarget: function (highlight) {\n        var targetval = this.values[0],\n            x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - this.options.get(\"targetWidth\") / 2),\n            targettop = Math.round(this.canvasHeight * .1),\n            targetheight = this.canvasHeight - targettop * 2,\n            color = this.options.get(\"targetColor\");\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, this.options);\n        }\n\n        return this.target.drawRect(x, targettop, this.options.get(\"targetWidth\") - 1, targetheight - 1, color, color);\n      },\n      render: function () {\n        var vlen = this.values.length,\n            target = this.target,\n            i,\n            shape;\n\n        if (!bullet._super.render.call(this)) {\n          return;\n        }\n\n        for (i = 2; i < vlen; i++) {\n          shape = this.renderRange(i).append();\n          this.shapes[shape.id] = \"r\" + i;\n          this.valueShapes[\"r\" + i] = shape.id;\n        }\n\n        if (this.values[1] !== null) {\n          shape = this.renderPerformance().append();\n          this.shapes[shape.id] = \"p1\";\n          this.valueShapes.p1 = shape.id;\n        }\n\n        if (this.values[0] !== null) {\n          shape = this.renderTarget().append();\n          this.shapes[shape.id] = \"t0\";\n          this.valueShapes.t0 = shape.id;\n        }\n\n        target.render();\n      }\n    });\n    $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {\n      type: \"pie\",\n      init: function (el, values, options, width, height) {\n        var total = 0,\n            i;\n\n        pie._super.init.call(this, el, values, options, width, height);\n\n        this.shapes = {};\n        this.valueShapes = {};\n        this.values = values = $.map(values, Number);\n\n        if (options.get(\"width\") === \"auto\") {\n          this.width = this.height;\n        }\n\n        if (values.length > 0) {\n          for (i = values.length; i--;) {\n            total += values[i];\n          }\n        }\n\n        this.total = total;\n        this.initTarget();\n        this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);\n      },\n      getRegion: function (el, x, y) {\n        var shapeid = this.target.getShapeAt(el, x, y);\n        return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;\n      },\n      getCurrentRegionFields: function () {\n        var currentRegion = this.currentRegion;\n        return {\n          isNull: this.values[currentRegion] === undefined,\n          value: this.values[currentRegion],\n          percent: this.values[currentRegion] / this.total * 100,\n          color: this.options.get(\"sliceColors\")[currentRegion % this.options.get(\"sliceColors\").length],\n          offset: currentRegion\n        };\n      },\n      changeHighlight: function (highlight) {\n        var currentRegion = this.currentRegion,\n            newslice = this.renderSlice(currentRegion, highlight),\n            shapeid = this.valueShapes[currentRegion];\n        delete this.shapes[shapeid];\n        this.target.replaceWithShape(shapeid, newslice);\n        this.valueShapes[currentRegion] = newslice.id;\n        this.shapes[newslice.id] = currentRegion;\n      },\n      renderSlice: function (valuenum, highlight) {\n        var target = this.target,\n            options = this.options,\n            radius = this.radius,\n            borderWidth = options.get(\"borderWidth\"),\n            offset = options.get(\"offset\"),\n            circle = 2 * Math.PI,\n            values = this.values,\n            total = this.total,\n            next = offset ? 2 * Math.PI * (offset / 360) : 0,\n            start,\n            end,\n            i,\n            vlen,\n            color;\n        vlen = values.length;\n\n        for (i = 0; i < vlen; i++) {\n          start = next;\n          end = next;\n\n          if (total > 0) {\n            end = next + circle * (values[i] / total);\n          }\n\n          if (valuenum === i) {\n            color = options.get(\"sliceColors\")[i % options.get(\"sliceColors\").length];\n\n            if (highlight) {\n              color = this.calcHighlightColor(color, options);\n            }\n\n            return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);\n          }\n\n          next = end;\n        }\n      },\n      render: function () {\n        var target = this.target,\n            values = this.values,\n            options = this.options,\n            radius = this.radius,\n            borderWidth = options.get(\"borderWidth\"),\n            donutWidth = options.get(\"donutWidth\"),\n            shape,\n            i;\n\n        if (!pie._super.render.call(this)) {\n          return;\n        }\n\n        if (borderWidth) {\n          target.drawCircle(radius, radius, Math.floor(radius - borderWidth / 2), options.get(\"borderColor\"), undefined, borderWidth).append();\n        }\n\n        for (i = values.length; i--;) {\n          if (values[i]) {\n            shape = this.renderSlice(i).append();\n            this.valueShapes[i] = shape.id;\n            this.shapes[shape.id] = i;\n          }\n        }\n\n        if (donutWidth) {\n          target.drawCircle(radius, radius, radius - donutWidth, options.get(\"donutColor\"), options.get(\"donutColor\"), 0).append();\n        }\n\n        target.render();\n      }\n    });\n    $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {\n      type: \"box\",\n      init: function (el, values, options, width, height) {\n        box._super.init.call(this, el, values, options, width, height);\n\n        this.values = $.map(values, Number);\n        this.width = options.get(\"width\") === \"auto\" ? \"4.0em\" : width;\n        this.initTarget();\n\n        if (!this.values.length) {\n          this.disabled = 1;\n        }\n      },\n      getRegion: function () {\n        return 1;\n      },\n      getCurrentRegionFields: function () {\n        var result = [{\n          field: \"lq\",\n          value: this.quartiles[0]\n        }, {\n          field: \"med\",\n          value: this.quartiles[1]\n        }, {\n          field: \"uq\",\n          value: this.quartiles[2]\n        }];\n\n        if (this.loutlier !== undefined) {\n          result.push({\n            field: \"lo\",\n            value: this.loutlier\n          });\n        }\n\n        if (this.routlier !== undefined) {\n          result.push({\n            field: \"ro\",\n            value: this.routlier\n          });\n        }\n\n        if (this.lwhisker !== undefined) {\n          result.push({\n            field: \"lw\",\n            value: this.lwhisker\n          });\n        }\n\n        if (this.rwhisker !== undefined) {\n          result.push({\n            field: \"rw\",\n            value: this.rwhisker\n          });\n        }\n\n        return result;\n      },\n      render: function () {\n        var target = this.target,\n            values = this.values,\n            vlen = values.length,\n            options = this.options,\n            canvasWidth = this.canvasWidth,\n            canvasHeight = this.canvasHeight,\n            minValue = options.get(\"chartRangeMin\") === undefined ? Math.min.apply(Math, values) : options.get(\"chartRangeMin\"),\n            maxValue = options.get(\"chartRangeMax\") === undefined ? Math.max.apply(Math, values) : options.get(\"chartRangeMax\"),\n            canvasLeft = 0,\n            lwhisker,\n            loutlier,\n            iqr,\n            q1,\n            q2,\n            q3,\n            rwhisker,\n            routlier,\n            i,\n            size,\n            unitSize;\n\n        if (!box._super.render.call(this)) {\n          return;\n        }\n\n        if (options.get(\"raw\")) {\n          if (options.get(\"showOutliers\") && values.length > 5) {\n            loutlier = values[0];\n            lwhisker = values[1];\n            q1 = values[2];\n            q2 = values[3];\n            q3 = values[4];\n            rwhisker = values[5];\n            routlier = values[6];\n          } else {\n            lwhisker = values[0];\n            q1 = values[1];\n            q2 = values[2];\n            q3 = values[3];\n            rwhisker = values[4];\n          }\n        } else {\n          values.sort(function (a, b) {\n            return a - b;\n          });\n          q1 = quartile(values, 1);\n          q2 = quartile(values, 2);\n          q3 = quartile(values, 3);\n          iqr = q3 - q1;\n\n          if (options.get(\"showOutliers\")) {\n            lwhisker = rwhisker = undefined;\n\n            for (i = 0; i < vlen; i++) {\n              if (lwhisker === undefined && values[i] > q1 - iqr * options.get(\"outlierIQR\")) {\n                lwhisker = values[i];\n              }\n\n              if (values[i] < q3 + iqr * options.get(\"outlierIQR\")) {\n                rwhisker = values[i];\n              }\n            }\n\n            loutlier = values[0];\n            routlier = values[vlen - 1];\n          } else {\n            lwhisker = values[0];\n            rwhisker = values[vlen - 1];\n          }\n        }\n\n        this.quartiles = [q1, q2, q3];\n        this.lwhisker = lwhisker;\n        this.rwhisker = rwhisker;\n        this.loutlier = loutlier;\n        this.routlier = routlier;\n        unitSize = canvasWidth / (maxValue - minValue + 1);\n\n        if (options.get(\"showOutliers\")) {\n          canvasLeft = Math.ceil(options.get(\"spotRadius\"));\n          canvasWidth -= 2 * Math.ceil(options.get(\"spotRadius\"));\n          unitSize = canvasWidth / (maxValue - minValue + 1);\n\n          if (loutlier < lwhisker) {\n            target.drawCircle((loutlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get(\"spotRadius\"), options.get(\"outlierLineColor\"), options.get(\"outlierFillColor\")).append();\n          }\n\n          if (routlier > rwhisker) {\n            target.drawCircle((routlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get(\"spotRadius\"), options.get(\"outlierLineColor\"), options.get(\"outlierFillColor\")).append();\n          }\n        }\n\n        target.drawRect(Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * .1), Math.round((q3 - q1) * unitSize), Math.round(canvasHeight * .8), options.get(\"boxLineColor\"), options.get(\"boxFillColor\")).append();\n        target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get(\"lineColor\")).append();\n        target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get(\"whiskerColor\")).append();\n        target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q3 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get(\"lineColor\")).append();\n        target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get(\"whiskerColor\")).append();\n        target.drawLine(Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * .1), Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * .9), options.get(\"medianColor\")).append();\n\n        if (options.get(\"target\")) {\n          size = Math.ceil(options.get(\"spotRadius\"));\n          target.drawLine(Math.round((options.get(\"target\") - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 - size), Math.round((options.get(\"target\") - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 + size), options.get(\"targetColor\")).append();\n          target.drawLine(Math.round((options.get(\"target\") - minValue) * unitSize + canvasLeft - size), Math.round(canvasHeight / 2), Math.round((options.get(\"target\") - minValue) * unitSize + canvasLeft + size), Math.round(canvasHeight / 2), options.get(\"targetColor\")).append();\n        }\n\n        target.render();\n      }\n    });\n    VShape = createClass({\n      init: function (target, id, type, args) {\n        this.target = target;\n        this.id = id;\n        this.type = type;\n        this.args = args;\n      },\n      append: function () {\n        this.target.appendShape(this);\n        return this;\n      }\n    });\n    VCanvas_base = createClass({\n      _pxregex: /(\\d+)(px)?\\s*$/i,\n      init: function (width, height, target) {\n        if (!width) {\n          return;\n        }\n\n        this.width = width;\n        this.height = height;\n        this.target = target;\n        this.lastShapeId = null;\n\n        if (target[0]) {\n          target = target[0];\n        }\n\n        $.data(target, \"_jqs_vcanvas\", this);\n      },\n      drawLine: function (x1, y1, x2, y2, lineColor, lineWidth) {\n        return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);\n      },\n      drawShape: function (path, lineColor, fillColor, lineWidth) {\n        return this._genShape(\"Shape\", [path, lineColor, fillColor, lineWidth]);\n      },\n      drawCircle: function (x, y, radius, lineColor, fillColor, lineWidth) {\n        return this._genShape(\"Circle\", [x, y, radius, lineColor, fillColor, lineWidth]);\n      },\n      drawPieSlice: function (x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n        return this._genShape(\"PieSlice\", [x, y, radius, startAngle, endAngle, lineColor, fillColor]);\n      },\n      drawRect: function (x, y, width, height, lineColor, fillColor) {\n        return this._genShape(\"Rect\", [x, y, width, height, lineColor, fillColor]);\n      },\n      getElement: function () {\n        return this.canvas;\n      },\n      getLastShapeId: function () {\n        return this.lastShapeId;\n      },\n      reset: function () {\n        alert(\"reset not implemented\");\n      },\n      _insert: function (el, target) {\n        $(target).html(el);\n      },\n      _calculatePixelDims: function (width, height, canvas) {\n        var match;\n        match = this._pxregex.exec(height);\n\n        if (match) {\n          this.pixelHeight = match[1];\n        } else {\n          this.pixelHeight = $(canvas).height();\n        }\n\n        match = this._pxregex.exec(width);\n\n        if (match) {\n          this.pixelWidth = match[1];\n        } else {\n          this.pixelWidth = $(canvas).width();\n        }\n      },\n      _genShape: function (shapetype, shapeargs) {\n        var id = shapeCount++;\n        shapeargs.unshift(id);\n        return new VShape(this, id, shapetype, shapeargs);\n      },\n      appendShape: function (shape) {\n        alert(\"appendShape not implemented\");\n      },\n      replaceWithShape: function (shapeid, shape) {\n        alert(\"replaceWithShape not implemented\");\n      },\n      insertAfterShape: function (shapeid, shape) {\n        alert(\"insertAfterShape not implemented\");\n      },\n      removeShapeId: function (shapeid) {\n        alert(\"removeShapeId not implemented\");\n      },\n      getShapeAt: function (el, x, y) {\n        alert(\"getShapeAt not implemented\");\n      },\n      render: function () {\n        alert(\"render not implemented\");\n      }\n    });\n    VCanvas_canvas = createClass(VCanvas_base, {\n      init: function (width, height, target, interact) {\n        VCanvas_canvas._super.init.call(this, width, height, target);\n\n        this.canvas = document.createElement(\"canvas\");\n\n        if (target[0]) {\n          target = target[0];\n        }\n\n        $.data(target, \"_jqs_vcanvas\", this);\n        $(this.canvas).css({\n          display: \"inline-block\",\n          width: width,\n          height: height,\n          verticalAlign: \"top\"\n        });\n\n        this._insert(this.canvas, target);\n\n        this._calculatePixelDims(width, height, this.canvas);\n\n        this.canvas.width = this.pixelWidth;\n        this.canvas.height = this.pixelHeight;\n        this.interact = interact;\n        this.shapes = {};\n        this.shapeseq = [];\n        this.currentTargetShapeId = undefined;\n        $(this.canvas).css({\n          width: this.pixelWidth,\n          height: this.pixelHeight\n        });\n      },\n      _getContext: function (lineColor, fillColor, lineWidth) {\n        var context = this.canvas.getContext(\"2d\");\n\n        if (lineColor !== undefined) {\n          context.strokeStyle = lineColor;\n        }\n\n        context.lineWidth = lineWidth === undefined ? 1 : lineWidth;\n\n        if (fillColor !== undefined) {\n          context.fillStyle = fillColor;\n        }\n\n        return context;\n      },\n      reset: function () {\n        var context = this._getContext();\n\n        context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);\n        this.shapes = {};\n        this.shapeseq = [];\n        this.currentTargetShapeId = undefined;\n      },\n      _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {\n        var context = this._getContext(lineColor, fillColor, lineWidth),\n            i,\n            plen;\n\n        context.beginPath();\n        context.moveTo(path[0][0] + .5, path[0][1] + .5);\n\n        for (i = 1, plen = path.length; i < plen; i++) {\n          context.lineTo(path[i][0] + .5, path[i][1] + .5);\n        }\n\n        if (lineColor !== undefined) {\n          context.stroke();\n        }\n\n        if (fillColor !== undefined) {\n          context.fill();\n        }\n\n        if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {\n          this.currentTargetShapeId = shapeid;\n        }\n      },\n      _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {\n        var context = this._getContext(lineColor, fillColor, lineWidth);\n\n        context.beginPath();\n        context.arc(x, y, radius, 0, 2 * Math.PI, false);\n\n        if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {\n          this.currentTargetShapeId = shapeid;\n        }\n\n        if (lineColor !== undefined) {\n          context.stroke();\n        }\n\n        if (fillColor !== undefined) {\n          context.fill();\n        }\n      },\n      _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n        var context = this._getContext(lineColor, fillColor);\n\n        context.beginPath();\n        context.moveTo(x, y);\n        context.arc(x, y, radius, startAngle, endAngle, false);\n        context.lineTo(x, y);\n        context.closePath();\n\n        if (lineColor !== undefined) {\n          context.stroke();\n        }\n\n        if (fillColor) {\n          context.fill();\n        }\n\n        if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {\n          this.currentTargetShapeId = shapeid;\n        }\n      },\n      _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {\n        return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);\n      },\n      appendShape: function (shape) {\n        this.shapes[shape.id] = shape;\n        this.shapeseq.push(shape.id);\n        this.lastShapeId = shape.id;\n        return shape.id;\n      },\n      replaceWithShape: function (shapeid, shape) {\n        var shapeseq = this.shapeseq,\n            i;\n        this.shapes[shape.id] = shape;\n\n        for (i = shapeseq.length; i--;) {\n          if (shapeseq[i] == shapeid) {\n            shapeseq[i] = shape.id;\n          }\n        }\n\n        delete this.shapes[shapeid];\n      },\n      replaceWithShapes: function (shapeids, shapes) {\n        var shapeseq = this.shapeseq,\n            shapemap = {},\n            sid,\n            i,\n            first;\n\n        for (i = shapeids.length; i--;) {\n          shapemap[shapeids[i]] = true;\n        }\n\n        for (i = shapeseq.length; i--;) {\n          sid = shapeseq[i];\n\n          if (shapemap[sid]) {\n            shapeseq.splice(i, 1);\n            delete this.shapes[sid];\n            first = i;\n          }\n        }\n\n        for (i = shapes.length; i--;) {\n          shapeseq.splice(first, 0, shapes[i].id);\n          this.shapes[shapes[i].id] = shapes[i];\n        }\n      },\n      insertAfterShape: function (shapeid, shape) {\n        var shapeseq = this.shapeseq,\n            i;\n\n        for (i = shapeseq.length; i--;) {\n          if (shapeseq[i] === shapeid) {\n            shapeseq.splice(i + 1, 0, shape.id);\n            this.shapes[shape.id] = shape;\n            return;\n          }\n        }\n      },\n      removeShapeId: function (shapeid) {\n        var shapeseq = this.shapeseq,\n            i;\n\n        for (i = shapeseq.length; i--;) {\n          if (shapeseq[i] === shapeid) {\n            shapeseq.splice(i, 1);\n            break;\n          }\n        }\n\n        delete this.shapes[shapeid];\n      },\n      getShapeAt: function (el, x, y) {\n        this.targetX = x;\n        this.targetY = y;\n        this.render();\n        return this.currentTargetShapeId;\n      },\n      render: function () {\n        var shapeseq = this.shapeseq,\n            shapes = this.shapes,\n            shapeCount = shapeseq.length,\n            context = this._getContext(),\n            shapeid,\n            shape,\n            i;\n\n        context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);\n\n        for (i = 0; i < shapeCount; i++) {\n          shapeid = shapeseq[i];\n          shape = shapes[shapeid];\n          this[\"_draw\" + shape.type].apply(this, shape.args);\n        }\n\n        if (!this.interact) {\n          this.shapes = {};\n          this.shapeseq = [];\n        }\n      }\n    });\n    VCanvas_vml = createClass(VCanvas_base, {\n      init: function (width, height, target) {\n        var groupel;\n\n        VCanvas_vml._super.init.call(this, width, height, target);\n\n        if (target[0]) {\n          target = target[0];\n        }\n\n        $.data(target, \"_jqs_vcanvas\", this);\n        this.canvas = document.createElement(\"span\");\n        $(this.canvas).css({\n          display: \"inline-block\",\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: width,\n          height: height,\n          margin: \"0px\",\n          padding: \"0px\",\n          verticalAlign: \"top\"\n        });\n\n        this._insert(this.canvas, target);\n\n        this._calculatePixelDims(width, height, this.canvas);\n\n        this.canvas.width = this.pixelWidth;\n        this.canvas.height = this.pixelHeight;\n        groupel = '<v:group coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + \" \" + this.pixelHeight + '\"' + ' style=\"position:absolute;top:0;left:0;width:' + this.pixelWidth + \"px;height=\" + this.pixelHeight + 'px;\"></v:group>';\n        this.canvas.insertAdjacentHTML(\"beforeEnd\", groupel);\n        this.group = $(this.canvas).children()[0];\n        this.rendered = false;\n        this.prerender = \"\";\n      },\n      _drawShape: function (shapeid, path, lineColor, fillColor, lineWidth) {\n        var vpath = [],\n            initial,\n            stroke,\n            fill,\n            closed,\n            vel,\n            plen,\n            i;\n\n        for (i = 0, plen = path.length; i < plen; i++) {\n          vpath[i] = \"\" + path[i][0] + \",\" + path[i][1];\n        }\n\n        initial = vpath.splice(0, 1);\n        lineWidth = lineWidth === undefined ? 1 : lineWidth;\n        stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"' + lineWidth + 'px\" strokeColor=\"' + lineColor + '\" ';\n        fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n        closed = vpath[0] === vpath[vpath.length - 1] ? \"x \" : \"\";\n        vel = '<v:shape coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + \" \" + this.pixelHeight + '\" ' + ' id=\"jqsshape' + shapeid + '\" ' + stroke + fill + ' style=\"position:absolute;left:0px;top:0px;height:' + this.pixelHeight + \"px;width:\" + this.pixelWidth + 'px;padding:0px;margin:0px;\" ' + ' path=\"m ' + initial + \" l \" + vpath.join(\", \") + \" \" + closed + 'e\">' + \" </v:shape>\";\n        return vel;\n      },\n      _drawCircle: function (shapeid, x, y, radius, lineColor, fillColor, lineWidth) {\n        var stroke, fill, vel;\n        x -= radius;\n        y -= radius;\n        stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"' + lineWidth + 'px\" strokeColor=\"' + lineColor + '\" ';\n        fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n        vel = \"<v:oval \" + ' id=\"jqsshape' + shapeid + '\" ' + stroke + fill + ' style=\"position:absolute;top:' + y + \"px; left:\" + x + \"px; width:\" + radius * 2 + \"px; height:\" + radius * 2 + 'px\"></v:oval>';\n        return vel;\n      },\n      _drawPieSlice: function (shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n        var vpath, startx, starty, endx, endy, stroke, fill, vel;\n\n        if (startAngle === endAngle) {\n          return \"\";\n        }\n\n        if (endAngle - startAngle === 2 * Math.PI) {\n          startAngle = 0;\n          endAngle = 2 * Math.PI;\n        }\n\n        startx = x + Math.round(Math.cos(startAngle) * radius);\n        starty = y + Math.round(Math.sin(startAngle) * radius);\n        endx = x + Math.round(Math.cos(endAngle) * radius);\n        endy = y + Math.round(Math.sin(endAngle) * radius);\n\n        if (startx === endx && starty === endy) {\n          if (endAngle - startAngle < Math.PI) {\n            return \"\";\n          }\n\n          startx = endx = x + radius;\n          starty = endy = y;\n        }\n\n        if (startx === endx && starty === endy && endAngle - startAngle < Math.PI) {\n          return \"\";\n        }\n\n        vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];\n        stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"1px\" strokeColor=\"' + lineColor + '\" ';\n        fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n        vel = '<v:shape coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + \" \" + this.pixelHeight + '\" ' + ' id=\"jqsshape' + shapeid + '\" ' + stroke + fill + ' style=\"position:absolute;left:0px;top:0px;height:' + this.pixelHeight + \"px;width:\" + this.pixelWidth + 'px;padding:0px;margin:0px;\" ' + ' path=\"m ' + x + \",\" + y + \" wa \" + vpath.join(\", \") + ' x e\">' + \" </v:shape>\";\n        return vel;\n      },\n      _drawRect: function (shapeid, x, y, width, height, lineColor, fillColor) {\n        return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);\n      },\n      reset: function () {\n        this.group.innerHTML = \"\";\n      },\n      appendShape: function (shape) {\n        var vel = this[\"_draw\" + shape.type].apply(this, shape.args);\n\n        if (this.rendered) {\n          this.group.insertAdjacentHTML(\"beforeEnd\", vel);\n        } else {\n          this.prerender += vel;\n        }\n\n        this.lastShapeId = shape.id;\n        return shape.id;\n      },\n      replaceWithShape: function (shapeid, shape) {\n        var existing = $(\"#jqsshape\" + shapeid),\n            vel = this[\"_draw\" + shape.type].apply(this, shape.args);\n        existing[0].outerHTML = vel;\n      },\n      replaceWithShapes: function (shapeids, shapes) {\n        var existing = $(\"#jqsshape\" + shapeids[0]),\n            replace = \"\",\n            slen = shapes.length,\n            i;\n\n        for (i = 0; i < slen; i++) {\n          replace += this[\"_draw\" + shapes[i].type].apply(this, shapes[i].args);\n        }\n\n        existing[0].outerHTML = replace;\n\n        for (i = 1; i < shapeids.length; i++) {\n          $(\"#jqsshape\" + shapeids[i]).remove();\n        }\n      },\n      insertAfterShape: function (shapeid, shape) {\n        var existing = $(\"#jqsshape\" + shapeid),\n            vel = this[\"_draw\" + shape.type].apply(this, shape.args);\n        existing[0].insertAdjacentHTML(\"afterEnd\", vel);\n      },\n      removeShapeId: function (shapeid) {\n        var existing = $(\"#jqsshape\" + shapeid);\n        this.group.removeChild(existing[0]);\n      },\n      getShapeAt: function (el, x, y) {\n        var shapeid = el.id.substr(8);\n        return shapeid;\n      },\n      render: function () {\n        if (!this.rendered) {\n          this.group.innerHTML = this.prerender;\n          this.rendered = true;\n        }\n      }\n    });\n  });\n})(document, Math);","map":null,"metadata":{},"sourceType":"script"}