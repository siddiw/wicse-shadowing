{"ast":null,"code":"/* jquery.nicescroll\r\n-- version 3.7.6\r\n-- copyright 2017-07-19 InuYaksa*2017\r\n-- licensed under the MIT\r\n--\r\n-- https://nicescroll.areaaperta.com/\r\n-- https://github.com/inuyaksa/jquery.nicescroll\r\n--\r\n*/\n\n/* jshint expr: true */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof exports === 'object') {\n    // Node/CommonJS.\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals.\n    factory(jQuery);\n  }\n})(function (jQuery) {\n  \"use strict\"; // globals\n\n  var domfocus = false,\n      mousefocus = false,\n      tabindexcounter = 0,\n      ascrailcounter = 2000,\n      globalmaxzindex = 0;\n  var $ = jQuery,\n      // sandbox\n  _doc = document,\n      _win = window,\n      $window = $(_win);\n  var delegatevents = []; // http://stackoverflow.com/questions/2161159/get-script-path\n\n  function getScriptPath() {\n    var scripts = _doc.currentScript || function () {\n      var s = _doc.getElementsByTagName('script');\n\n      return s.length ? s[s.length - 1] : false;\n    }();\n\n    var path = scripts ? scripts.src.split('?')[0] : '';\n    return path.split('/').length > 0 ? path.split('/').slice(0, -1).join('/') + '/' : '';\n  } // based on code by Paul Irish https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/  \n\n\n  var setAnimationFrame = _win.requestAnimationFrame || _win.webkitRequestAnimationFrame || _win.mozRequestAnimationFrame || false;\n  var clearAnimationFrame = _win.cancelAnimationFrame || _win.webkitCancelAnimationFrame || _win.mozCancelAnimationFrame || false;\n\n  if (!setAnimationFrame) {\n    var anilasttime = 0;\n\n    setAnimationFrame = function (callback, element) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - anilasttime));\n\n      var id = _win.setTimeout(function () {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n\n      anilasttime = currTime + timeToCall;\n      return id;\n    };\n\n    clearAnimationFrame = function (id) {\n      _win.clearTimeout(id);\n    };\n  } else {\n    if (!_win.cancelAnimationFrame) clearAnimationFrame = function (id) {};\n  }\n\n  var ClsMutationObserver = _win.MutationObserver || _win.WebKitMutationObserver || false;\n\n  var now = Date.now || function () {\n    return new Date().getTime();\n  };\n\n  var _globaloptions = {\n    zindex: \"auto\",\n    cursoropacitymin: 0,\n    cursoropacitymax: 1,\n    cursorcolor: \"#424242\",\n    cursorwidth: \"6px\",\n    cursorborder: \"1px solid #fff\",\n    cursorborderradius: \"5px\",\n    scrollspeed: 40,\n    mousescrollstep: 9 * 3,\n    touchbehavior: false,\n    // deprecated\n    emulatetouch: false,\n    // replacing touchbehavior\n    hwacceleration: true,\n    usetransition: true,\n    boxzoom: false,\n    dblclickzoom: true,\n    gesturezoom: true,\n    grabcursorenabled: true,\n    autohidemode: true,\n    background: \"\",\n    iframeautoresize: true,\n    cursorminheight: 32,\n    preservenativescrolling: true,\n    railoffset: false,\n    railhoffset: false,\n    bouncescroll: true,\n    spacebarenabled: true,\n    railpadding: {\n      top: 0,\n      right: 0,\n      left: 0,\n      bottom: 0\n    },\n    disableoutline: true,\n    horizrailenabled: true,\n    railalign: \"right\",\n    railvalign: \"bottom\",\n    enabletranslate3d: true,\n    enablemousewheel: true,\n    enablekeyboard: true,\n    smoothscroll: true,\n    sensitiverail: true,\n    enablemouselockapi: true,\n    //      cursormaxheight:false,\n    cursorfixedheight: false,\n    directionlockdeadzone: 6,\n    hidecursordelay: 400,\n    nativeparentscrolling: true,\n    enablescrollonselection: true,\n    overflowx: true,\n    overflowy: true,\n    cursordragspeed: 0.3,\n    rtlmode: \"auto\",\n    cursordragontouch: false,\n    oneaxismousemode: \"auto\",\n    scriptpath: getScriptPath(),\n    preventmultitouchscrolling: true,\n    disablemutationobserver: false,\n    enableobserver: true,\n    scrollbarid: false\n  };\n  var browserdetected = false;\n\n  var getBrowserDetection = function () {\n    if (browserdetected) return browserdetected;\n\n    var _el = _doc.createElement('DIV'),\n        _style = _el.style,\n        _agent = navigator.userAgent,\n        _platform = navigator.platform,\n        d = {};\n\n    d.haspointerlock = \"pointerLockElement\" in _doc || \"webkitPointerLockElement\" in _doc || \"mozPointerLockElement\" in _doc;\n    d.isopera = \"opera\" in _win; // 12-\n\n    d.isopera12 = d.isopera && \"getUserMedia\" in navigator;\n    d.isoperamini = Object.prototype.toString.call(_win.operamini) === \"[object OperaMini]\";\n    d.isie = \"all\" in _doc && \"attachEvent\" in _el && !d.isopera; //IE10-\n\n    d.isieold = d.isie && !(\"msInterpolationMode\" in _style); // IE6 and older\n\n    d.isie7 = d.isie && !d.isieold && (!(\"documentMode\" in _doc) || _doc.documentMode === 7);\n    d.isie8 = d.isie && \"documentMode\" in _doc && _doc.documentMode === 8;\n    d.isie9 = d.isie && \"performance\" in _win && _doc.documentMode === 9;\n    d.isie10 = d.isie && \"performance\" in _win && _doc.documentMode === 10;\n    d.isie11 = \"msRequestFullscreen\" in _el && _doc.documentMode >= 11; // IE11+\n\n    d.ismsedge = \"msCredentials\" in _win; // MS Edge 14+\n\n    d.ismozilla = \"MozAppearance\" in _style;\n    d.iswebkit = !d.ismsedge && \"WebkitAppearance\" in _style;\n    d.ischrome = d.iswebkit && \"chrome\" in _win;\n    d.ischrome38 = d.ischrome && \"touchAction\" in _style; // behavior changed in touch emulation    \n\n    d.ischrome22 = !d.ischrome38 && d.ischrome && d.haspointerlock;\n    d.ischrome26 = !d.ischrome38 && d.ischrome && \"transition\" in _style; // issue with transform detection (maintain prefix)\n\n    d.cantouch = \"ontouchstart\" in _doc.documentElement || \"ontouchstart\" in _win; // with detection for Chrome Touch Emulation    \n\n    d.hasw3ctouch = (_win.PointerEvent || false) && (navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0); //IE11 pointer events, following W3C Pointer Events spec\n\n    d.hasmstouch = !d.hasw3ctouch && (_win.MSPointerEvent || false); // IE10 pointer events\n\n    d.ismac = /^mac$/i.test(_platform);\n    d.isios = d.cantouch && /iphone|ipad|ipod/i.test(_platform);\n    d.isios4 = d.isios && !(\"seal\" in Object);\n    d.isios7 = d.isios && \"webkitHidden\" in _doc; //iOS 7+\n\n    d.isios8 = d.isios && \"hidden\" in _doc; //iOS 8+\n\n    d.isios10 = d.isios && _win.Proxy; //iOS 10+\n\n    d.isandroid = /android/i.test(_agent);\n    d.haseventlistener = \"addEventListener\" in _el;\n    d.trstyle = false;\n    d.hastransform = false;\n    d.hastranslate3d = false;\n    d.transitionstyle = false;\n    d.hastransition = false;\n    d.transitionend = false;\n    d.trstyle = \"transform\";\n\n    d.hastransform = \"transform\" in _style || function () {\n      var check = ['msTransform', 'webkitTransform', 'MozTransform', 'OTransform'];\n\n      for (var a = 0, c = check.length; a < c; a++) {\n        if (_style[check[a]] !== undefined) {\n          d.trstyle = check[a];\n          break;\n        }\n      }\n\n      d.hastransform = !!d.trstyle;\n    }();\n\n    if (d.hastransform) {\n      _style[d.trstyle] = \"translate3d(1px,2px,3px)\";\n      d.hastranslate3d = /translate3d/.test(_style[d.trstyle]);\n    }\n\n    d.transitionstyle = \"transition\";\n    d.prefixstyle = '';\n    d.transitionend = \"transitionend\";\n\n    d.hastransition = \"transition\" in _style || function () {\n      d.transitionend = false;\n      var check = ['webkitTransition', 'msTransition', 'MozTransition', 'OTransition', 'OTransition', 'KhtmlTransition'];\n      var prefix = ['-webkit-', '-ms-', '-moz-', '-o-', '-o', '-khtml-'];\n      var evs = ['webkitTransitionEnd', 'msTransitionEnd', 'transitionend', 'otransitionend', 'oTransitionEnd', 'KhtmlTransitionEnd'];\n\n      for (var a = 0, c = check.length; a < c; a++) {\n        if (check[a] in _style) {\n          d.transitionstyle = check[a];\n          d.prefixstyle = prefix[a];\n          d.transitionend = evs[a];\n          break;\n        }\n      }\n\n      if (d.ischrome26) d.prefixstyle = prefix[1]; // always use prefix\n\n      d.hastransition = d.transitionstyle;\n    }();\n\n    function detectCursorGrab() {\n      var lst = ['grab', '-webkit-grab', '-moz-grab'];\n      if (d.ischrome && !d.ischrome38 || d.isie) lst = []; // force setting for IE returns false positive and chrome cursor bug\n\n      for (var a = 0, l = lst.length; a < l; a++) {\n        var p = lst[a];\n        _style.cursor = p;\n        if (_style.cursor == p) return p;\n      }\n\n      return 'url(https://cdnjs.cloudflare.com/ajax/libs/slider-pro/1.3.0/css/images/openhand.cur),n-resize'; // thanks to https://cdnjs.com/ for the openhand cursor!\n    }\n\n    d.cursorgrabvalue = detectCursorGrab();\n    d.hasmousecapture = \"setCapture\" in _el;\n    d.hasMutationObserver = ClsMutationObserver !== false;\n    _el = null; //memory released\n\n    browserdetected = d;\n    return d;\n  };\n\n  var NiceScrollClass = function (myopt, me) {\n    var self = this;\n    this.version = '3.7.6';\n    this.name = 'nicescroll';\n    this.me = me;\n    var $body = $(\"body\");\n    var opt = this.opt = {\n      doc: $body,\n      win: false\n    };\n    $.extend(opt, _globaloptions); // clone opts\n    // Options for internal use\n\n    opt.snapbackspeed = 80;\n\n    if (myopt || false) {\n      for (var a in opt) {\n        if (myopt[a] !== undefined) opt[a] = myopt[a];\n      }\n    }\n\n    if (opt.disablemutationobserver) ClsMutationObserver = false;\n    this.doc = opt.doc;\n    this.iddoc = this.doc && this.doc[0] ? this.doc[0].id || '' : '';\n    this.ispage = /^BODY|HTML/.test(opt.win ? opt.win[0].nodeName : this.doc[0].nodeName);\n    this.haswrapper = opt.win !== false;\n    this.win = opt.win || (this.ispage ? $window : this.doc);\n    this.docscroll = this.ispage && !this.haswrapper ? $window : this.win;\n    this.body = $body;\n    this.viewport = false;\n    this.isfixed = false;\n    this.iframe = false;\n    this.isiframe = this.doc[0].nodeName == 'IFRAME' && this.win[0].nodeName == 'IFRAME';\n    this.istextarea = this.win[0].nodeName == 'TEXTAREA';\n    this.forcescreen = false; //force to use screen position on events\n\n    this.canshowonmouseevent = opt.autohidemode != \"scroll\"; // Events jump table    \n\n    this.onmousedown = false;\n    this.onmouseup = false;\n    this.onmousemove = false;\n    this.onmousewheel = false;\n    this.onkeypress = false;\n    this.ongesturezoom = false;\n    this.onclick = false; // Nicescroll custom events\n\n    this.onscrollstart = false;\n    this.onscrollend = false;\n    this.onscrollcancel = false;\n    this.onzoomin = false;\n    this.onzoomout = false; // Let's start!  \n\n    this.view = false;\n    this.page = false;\n    this.scroll = {\n      x: 0,\n      y: 0\n    };\n    this.scrollratio = {\n      x: 0,\n      y: 0\n    };\n    this.cursorheight = 20;\n    this.scrollvaluemax = 0; // http://dev.w3.org/csswg/css-writing-modes-3/#logical-to-physical\n    // http://dev.w3.org/csswg/css-writing-modes-3/#svg-writing-mode\n\n    if (opt.rtlmode == \"auto\") {\n      var target = this.win[0] == _win ? this.body : this.win;\n      var writingMode = target.css(\"writing-mode\") || target.css(\"-webkit-writing-mode\") || target.css(\"-ms-writing-mode\") || target.css(\"-moz-writing-mode\");\n\n      if (writingMode == \"horizontal-tb\" || writingMode == \"lr-tb\" || writingMode === \"\") {\n        this.isrtlmode = target.css(\"direction\") == \"rtl\";\n        this.isvertical = false;\n      } else {\n        this.isrtlmode = writingMode == \"vertical-rl\" || writingMode == \"tb\" || writingMode == \"tb-rl\" || writingMode == \"rl-tb\";\n        this.isvertical = writingMode == \"vertical-rl\" || writingMode == \"tb\" || writingMode == \"tb-rl\";\n      }\n    } else {\n      this.isrtlmode = opt.rtlmode === true;\n      this.isvertical = false;\n    } //    this.checkrtlmode = false;\n\n\n    this.scrollrunning = false;\n    this.scrollmom = false;\n    this.observer = false; // observer div changes\n\n    this.observerremover = false; // observer on parent for remove detection\n\n    this.observerbody = false; // observer on body for position change\n\n    if (opt.scrollbarid !== false) {\n      this.id = opt.scrollbarid;\n    } else {\n      do {\n        this.id = \"ascrail\" + ascrailcounter++;\n      } while (_doc.getElementById(this.id));\n    }\n\n    this.rail = false;\n    this.cursor = false;\n    this.cursorfreezed = false;\n    this.selectiondrag = false;\n    this.zoom = false;\n    this.zoomactive = false;\n    this.hasfocus = false;\n    this.hasmousefocus = false; //this.visibility = true;\n\n    this.railslocked = false; // locked by resize\n\n    this.locked = false; // prevent lost of locked status sets by user\n\n    this.hidden = false; // rails always hidden\n\n    this.cursoractive = true; // user can interact with cursors\n\n    this.wheelprevented = false; //prevent mousewheel event\n\n    this.overflowx = opt.overflowx;\n    this.overflowy = opt.overflowy;\n    this.nativescrollingarea = false;\n    this.checkarea = 0;\n    this.events = []; // event list for unbind\n\n    this.saved = {}; // style saved\n\n    this.delaylist = {};\n    this.synclist = {};\n    this.lastdeltax = 0;\n    this.lastdeltay = 0;\n    this.detected = getBrowserDetection();\n    var cap = $.extend({}, this.detected);\n    this.canhwscroll = cap.hastransform && opt.hwacceleration;\n    this.ishwscroll = this.canhwscroll && self.haswrapper;\n\n    if (!this.isrtlmode) {\n      this.hasreversehr = false;\n    } else if (this.isvertical) {\n      // RTL mode with reverse horizontal axis\n      this.hasreversehr = !(cap.iswebkit || cap.isie || cap.isie11);\n    } else {\n      this.hasreversehr = !(cap.iswebkit || cap.isie && !cap.isie10 && !cap.isie11);\n    }\n\n    this.istouchcapable = false; // desktop devices with touch screen support\n    //## Check WebKit-based desktop with touch support\n    //## + Firefox 18 nightly build (desktop) false positive (or desktop with touch support)\n\n    if (!cap.cantouch && (cap.hasw3ctouch || cap.hasmstouch)) {\n      // desktop device with multiple input\n      this.istouchcapable = true;\n    } else if (cap.cantouch && !cap.isios && !cap.isandroid && (cap.iswebkit || cap.ismozilla)) {\n      this.istouchcapable = true;\n    } //## disable MouseLock API on user request\n\n\n    if (!opt.enablemouselockapi) {\n      cap.hasmousecapture = false;\n      cap.haspointerlock = false;\n    }\n\n    this.debounced = function (name, fn, tm) {\n      if (!self) return;\n      var dd = self.delaylist[name] || false;\n\n      if (!dd) {\n        self.delaylist[name] = {\n          h: setAnimationFrame(function () {\n            self.delaylist[name].fn.call(self);\n            self.delaylist[name] = false;\n          }, tm)\n        };\n        fn.call(self);\n      }\n\n      self.delaylist[name].fn = fn;\n    };\n\n    this.synched = function (name, fn) {\n      if (self.synclist[name]) self.synclist[name] = fn;else {\n        self.synclist[name] = fn;\n        setAnimationFrame(function () {\n          if (!self) return;\n          self.synclist[name] && self.synclist[name].call(self);\n          self.synclist[name] = null;\n        });\n      }\n    };\n\n    this.unsynched = function (name) {\n      if (self.synclist[name]) self.synclist[name] = false;\n    };\n\n    this.css = function (el, pars) {\n      // save & set\n      for (var n in pars) {\n        self.saved.css.push([el, n, el.css(n)]);\n        el.css(n, pars[n]);\n      }\n    };\n\n    this.scrollTop = function (val) {\n      return val === undefined ? self.getScrollTop() : self.setScrollTop(val);\n    };\n\n    this.scrollLeft = function (val) {\n      return val === undefined ? self.getScrollLeft() : self.setScrollLeft(val);\n    }; // derived by by Dan Pupius www.pupius.net\n\n\n    var BezierClass = function (st, ed, spd, p1, p2, p3, p4) {\n      this.st = st;\n      this.ed = ed;\n      this.spd = spd;\n      this.p1 = p1 || 0;\n      this.p2 = p2 || 1;\n      this.p3 = p3 || 0;\n      this.p4 = p4 || 1;\n      this.ts = now();\n      this.df = ed - st;\n    };\n\n    BezierClass.prototype = {\n      B2: function (t) {\n        return 3 * (1 - t) * (1 - t) * t;\n      },\n      B3: function (t) {\n        return 3 * (1 - t) * t * t;\n      },\n      B4: function (t) {\n        return t * t * t;\n      },\n      getPos: function () {\n        return (now() - this.ts) / this.spd;\n      },\n      getNow: function () {\n        var pc = (now() - this.ts) / this.spd;\n        var bz = this.B2(pc) + this.B3(pc) + this.B4(pc);\n        return pc >= 1 ? this.ed : this.st + this.df * bz | 0;\n      },\n      update: function (ed, spd) {\n        this.st = this.getNow();\n        this.ed = ed;\n        this.spd = spd;\n        this.ts = now();\n        this.df = this.ed - this.st;\n        return this;\n      }\n    }; //derived from http://stackoverflow.com/questions/11236090/\n\n    function getMatrixValues() {\n      var tr = self.doc.css(cap.trstyle);\n\n      if (tr && tr.substr(0, 6) == \"matrix\") {\n        return tr.replace(/^.*\\((.*)\\)$/g, \"$1\").replace(/px/g, '').split(/, +/);\n      }\n\n      return false;\n    }\n\n    if (this.ishwscroll) {\n      // hw accelerated scroll\n      this.doc.translate = {\n        x: 0,\n        y: 0,\n        tx: \"0px\",\n        ty: \"0px\"\n      }; //this one can help to enable hw accel on ios6 http://indiegamr.com/ios6-html-hardware-acceleration-changes-and-how-to-fix-them/\n\n      if (cap.hastranslate3d && cap.isios) this.doc.css(\"-webkit-backface-visibility\", \"hidden\"); // prevent flickering http://stackoverflow.com/questions/3461441/      \n\n      this.getScrollTop = function (last) {\n        if (!last) {\n          var mtx = getMatrixValues();\n          if (mtx) return mtx.length == 16 ? -mtx[13] : -mtx[5]; //matrix3d 16 on IE10\n\n          if (self.timerscroll && self.timerscroll.bz) return self.timerscroll.bz.getNow();\n        }\n\n        return self.doc.translate.y;\n      };\n\n      this.getScrollLeft = function (last) {\n        if (!last) {\n          var mtx = getMatrixValues();\n          if (mtx) return mtx.length == 16 ? -mtx[12] : -mtx[4]; //matrix3d 16 on IE10\n\n          if (self.timerscroll && self.timerscroll.bh) return self.timerscroll.bh.getNow();\n        }\n\n        return self.doc.translate.x;\n      };\n\n      this.notifyScrollEvent = function (el) {\n        var e = _doc.createEvent(\"UIEvents\");\n\n        e.initUIEvent(\"scroll\", false, false, _win, 1);\n        e.niceevent = true;\n        el.dispatchEvent(e);\n      };\n\n      var cxscrollleft = this.isrtlmode ? 1 : -1;\n\n      if (cap.hastranslate3d && opt.enabletranslate3d) {\n        this.setScrollTop = function (val, silent) {\n          self.doc.translate.y = val;\n          self.doc.translate.ty = val * -1 + \"px\";\n          self.doc.css(cap.trstyle, \"translate3d(\" + self.doc.translate.tx + \",\" + self.doc.translate.ty + \",0)\");\n          if (!silent) self.notifyScrollEvent(self.win[0]);\n        };\n\n        this.setScrollLeft = function (val, silent) {\n          self.doc.translate.x = val;\n          self.doc.translate.tx = val * cxscrollleft + \"px\";\n          self.doc.css(cap.trstyle, \"translate3d(\" + self.doc.translate.tx + \",\" + self.doc.translate.ty + \",0)\");\n          if (!silent) self.notifyScrollEvent(self.win[0]);\n        };\n      } else {\n        this.setScrollTop = function (val, silent) {\n          self.doc.translate.y = val;\n          self.doc.translate.ty = val * -1 + \"px\";\n          self.doc.css(cap.trstyle, \"translate(\" + self.doc.translate.tx + \",\" + self.doc.translate.ty + \")\");\n          if (!silent) self.notifyScrollEvent(self.win[0]);\n        };\n\n        this.setScrollLeft = function (val, silent) {\n          self.doc.translate.x = val;\n          self.doc.translate.tx = val * cxscrollleft + \"px\";\n          self.doc.css(cap.trstyle, \"translate(\" + self.doc.translate.tx + \",\" + self.doc.translate.ty + \")\");\n          if (!silent) self.notifyScrollEvent(self.win[0]);\n        };\n      }\n    } else {\n      // native scroll\n      this.getScrollTop = function () {\n        return self.docscroll.scrollTop();\n      };\n\n      this.setScrollTop = function (val) {\n        self.docscroll.scrollTop(val);\n      };\n\n      this.getScrollLeft = function () {\n        var val;\n\n        if (!self.hasreversehr) {\n          val = self.docscroll.scrollLeft();\n        } else if (self.detected.ismozilla) {\n          val = self.page.maxw - Math.abs(self.docscroll.scrollLeft());\n        } else {\n          val = self.page.maxw - self.docscroll.scrollLeft();\n        }\n\n        return val;\n      };\n\n      this.setScrollLeft = function (val) {\n        return setTimeout(function () {\n          if (!self) return;\n\n          if (self.hasreversehr) {\n            if (self.detected.ismozilla) {\n              val = -(self.page.maxw - val);\n            } else {\n              val = self.page.maxw - val;\n            }\n          }\n\n          return self.docscroll.scrollLeft(val);\n        }, 1);\n      };\n    }\n\n    this.getTarget = function (e) {\n      if (!e) return false;\n      if (e.target) return e.target;\n      if (e.srcElement) return e.srcElement;\n      return false;\n    };\n\n    this.hasParent = function (e, id) {\n      if (!e) return false;\n      var el = e.target || e.srcElement || e || false;\n\n      while (el && el.id != id) {\n        el = el.parentNode || false;\n      }\n\n      return el !== false;\n    };\n\n    function getZIndex() {\n      var dom = self.win;\n      if (\"zIndex\" in dom) return dom.zIndex(); // use jQuery UI method when available\n\n      while (dom.length > 0) {\n        if (dom[0].nodeType == 9) return false;\n        var zi = dom.css('zIndex');\n        if (!isNaN(zi) && zi !== 0) return parseInt(zi);\n        dom = dom.parent();\n      }\n\n      return false;\n    } //inspired by http://forum.jquery.com/topic/width-includes-border-width-when-set-to-thin-medium-thick-in-ie\n\n\n    var _convertBorderWidth = {\n      \"thin\": 1,\n      \"medium\": 3,\n      \"thick\": 5\n    };\n\n    function getWidthToPixel(dom, prop, chkheight) {\n      var wd = dom.css(prop);\n      var px = parseFloat(wd);\n\n      if (isNaN(px)) {\n        px = _convertBorderWidth[wd] || 0;\n        var brd = px == 3 ? chkheight ? self.win.outerHeight() - self.win.innerHeight() : self.win.outerWidth() - self.win.innerWidth() : 1; //DON'T TRUST CSS\n\n        if (self.isie8 && px) px += 1;\n        return brd ? px : 0;\n      }\n\n      return px;\n    }\n\n    this.getDocumentScrollOffset = function () {\n      return {\n        top: _win.pageYOffset || _doc.documentElement.scrollTop,\n        left: _win.pageXOffset || _doc.documentElement.scrollLeft\n      };\n    };\n\n    this.getOffset = function () {\n      if (self.isfixed) {\n        var ofs = self.win.offset(); // fix Chrome auto issue (when right/bottom props only)\n\n        var scrl = self.getDocumentScrollOffset();\n        ofs.top -= scrl.top;\n        ofs.left -= scrl.left;\n        return ofs;\n      }\n\n      var ww = self.win.offset();\n      if (!self.viewport) return ww;\n      var vp = self.viewport.offset();\n      return {\n        top: ww.top - vp.top,\n        left: ww.left - vp.left\n      };\n    };\n\n    this.updateScrollBar = function (len) {\n      var pos, off;\n\n      if (self.ishwscroll) {\n        self.rail.css({\n          height: self.win.innerHeight() - (opt.railpadding.top + opt.railpadding.bottom)\n        });\n        if (self.railh) self.railh.css({\n          width: self.win.innerWidth() - (opt.railpadding.left + opt.railpadding.right)\n        });\n      } else {\n        var wpos = self.getOffset();\n        pos = {\n          top: wpos.top,\n          left: wpos.left - (opt.railpadding.left + opt.railpadding.right)\n        };\n        pos.top += getWidthToPixel(self.win, 'border-top-width', true);\n        pos.left += self.rail.align ? self.win.outerWidth() - getWidthToPixel(self.win, 'border-right-width') - self.rail.width : getWidthToPixel(self.win, 'border-left-width');\n        off = opt.railoffset;\n\n        if (off) {\n          if (off.top) pos.top += off.top;\n          if (off.left) pos.left += off.left;\n        }\n\n        if (!self.railslocked) self.rail.css({\n          top: pos.top,\n          left: pos.left,\n          height: (len ? len.h : self.win.innerHeight()) - (opt.railpadding.top + opt.railpadding.bottom)\n        });\n\n        if (self.zoom) {\n          self.zoom.css({\n            top: pos.top + 1,\n            left: self.rail.align == 1 ? pos.left - 20 : pos.left + self.rail.width + 4\n          });\n        }\n\n        if (self.railh && !self.railslocked) {\n          pos = {\n            top: wpos.top,\n            left: wpos.left\n          };\n          off = opt.railhoffset;\n\n          if (off) {\n            if (off.top) pos.top += off.top;\n            if (off.left) pos.left += off.left;\n          }\n\n          var y = self.railh.align ? pos.top + getWidthToPixel(self.win, 'border-top-width', true) + self.win.innerHeight() - self.railh.height : pos.top + getWidthToPixel(self.win, 'border-top-width', true);\n          var x = pos.left + getWidthToPixel(self.win, 'border-left-width');\n          self.railh.css({\n            top: y - (opt.railpadding.top + opt.railpadding.bottom),\n            left: x,\n            width: self.railh.width\n          });\n        }\n      }\n    };\n\n    this.doRailClick = function (e, dbl, hr) {\n      var fn, pg, cur, pos;\n      if (self.railslocked) return;\n      self.cancelEvent(e);\n\n      if (!(\"pageY\" in e)) {\n        e.pageX = e.clientX + _doc.documentElement.scrollLeft;\n        e.pageY = e.clientY + _doc.documentElement.scrollTop;\n      }\n\n      if (dbl) {\n        fn = hr ? self.doScrollLeft : self.doScrollTop;\n        cur = hr ? (e.pageX - self.railh.offset().left - self.cursorwidth / 2) * self.scrollratio.x : (e.pageY - self.rail.offset().top - self.cursorheight / 2) * self.scrollratio.y;\n        self.unsynched(\"relativexy\");\n        fn(cur | 0);\n      } else {\n        fn = hr ? self.doScrollLeftBy : self.doScrollBy;\n        cur = hr ? self.scroll.x : self.scroll.y;\n        pos = hr ? e.pageX - self.railh.offset().left : e.pageY - self.rail.offset().top;\n        pg = hr ? self.view.w : self.view.h;\n        fn(cur >= pos ? pg : -pg);\n      }\n    };\n\n    self.newscrolly = self.newscrollx = 0;\n    self.hasanimationframe = \"requestAnimationFrame\" in _win;\n    self.hascancelanimationframe = \"cancelAnimationFrame\" in _win;\n    self.hasborderbox = false;\n\n    this.init = function () {\n      self.saved.css = [];\n      if (cap.isoperamini) return true; // SORRY, DO NOT WORK!\n\n      if (cap.isandroid && !(\"hidden\" in _doc)) return true; // Android 3- SORRY, DO NOT WORK!\n\n      opt.emulatetouch = opt.emulatetouch || opt.touchbehavior; // mantain compatibility with \"touchbehavior\"      \n\n      self.hasborderbox = _win.getComputedStyle && _win.getComputedStyle(_doc.body)['box-sizing'] === \"border-box\";\n      var _scrollyhidden = {\n        'overflow-y': 'hidden'\n      };\n      if (cap.isie11 || cap.isie10) _scrollyhidden['-ms-overflow-style'] = 'none'; // IE 10 & 11 is always a world apart!\n\n      if (self.ishwscroll) {\n        this.doc.css(cap.transitionstyle, cap.prefixstyle + 'transform 0ms ease-out');\n        if (cap.transitionend) self.bind(self.doc, cap.transitionend, self.onScrollTransitionEnd, false); //I have got to do something usefull!!\n      }\n\n      self.zindex = \"auto\";\n\n      if (!self.ispage && opt.zindex == \"auto\") {\n        self.zindex = getZIndex() || \"auto\";\n      } else {\n        self.zindex = opt.zindex;\n      }\n\n      if (!self.ispage && self.zindex != \"auto\" && self.zindex > globalmaxzindex) {\n        globalmaxzindex = self.zindex;\n      }\n\n      if (self.isie && self.zindex === 0 && opt.zindex == \"auto\") {\n        // fix IE auto == 0\n        self.zindex = \"auto\";\n      }\n\n      if (!self.ispage || !cap.isieold) {\n        var cont = self.docscroll;\n        if (self.ispage) cont = self.haswrapper ? self.win : self.doc;\n        self.css(cont, _scrollyhidden);\n\n        if (self.ispage && (cap.isie11 || cap.isie)) {\n          // IE 7-11\n          self.css($(\"html\"), _scrollyhidden);\n        }\n\n        if (cap.isios && !self.ispage && !self.haswrapper) self.css($body, {\n          \"-webkit-overflow-scrolling\": \"touch\"\n        }); //force hw acceleration\n\n        var cursor = $(_doc.createElement('div'));\n        cursor.css({\n          position: \"relative\",\n          top: 0,\n          \"float\": \"right\",\n          width: opt.cursorwidth,\n          height: 0,\n          'background-color': opt.cursorcolor,\n          border: opt.cursorborder,\n          'background-clip': 'padding-box',\n          '-webkit-border-radius': opt.cursorborderradius,\n          '-moz-border-radius': opt.cursorborderradius,\n          'border-radius': opt.cursorborderradius\n        });\n        cursor.addClass('nicescroll-cursors');\n        self.cursor = cursor;\n        var rail = $(_doc.createElement('div'));\n        rail.attr('id', self.id);\n        rail.addClass('nicescroll-rails nicescroll-rails-vr');\n        var v,\n            a,\n            kp = [\"left\", \"right\", \"top\", \"bottom\"]; //**\n\n        for (var n in kp) {\n          a = kp[n];\n          v = opt.railpadding[a] || 0;\n          v && rail.css(\"padding-\" + a, v + \"px\");\n        }\n\n        rail.append(cursor);\n        rail.width = Math.max(parseFloat(opt.cursorwidth), cursor.outerWidth());\n        rail.css({\n          width: rail.width + \"px\",\n          zIndex: self.zindex,\n          background: opt.background,\n          cursor: \"default\"\n        });\n        rail.visibility = true;\n        rail.scrollable = true;\n        rail.align = opt.railalign == \"left\" ? 0 : 1;\n        self.rail = rail;\n        self.rail.drag = false;\n        var zoom = false;\n\n        if (opt.boxzoom && !self.ispage && !cap.isieold) {\n          zoom = _doc.createElement('div');\n          self.bind(zoom, \"click\", self.doZoom);\n          self.bind(zoom, \"mouseenter\", function () {\n            self.zoom.css('opacity', opt.cursoropacitymax);\n          });\n          self.bind(zoom, \"mouseleave\", function () {\n            self.zoom.css('opacity', opt.cursoropacitymin);\n          });\n          self.zoom = $(zoom);\n          self.zoom.css({\n            cursor: \"pointer\",\n            zIndex: self.zindex,\n            backgroundImage: 'url(' + opt.scriptpath + 'zoomico.png)',\n            height: 18,\n            width: 18,\n            backgroundPosition: '0 0'\n          });\n          if (opt.dblclickzoom) self.bind(self.win, \"dblclick\", self.doZoom);\n\n          if (cap.cantouch && opt.gesturezoom) {\n            self.ongesturezoom = function (e) {\n              if (e.scale > 1.5) self.doZoomIn(e);\n              if (e.scale < 0.8) self.doZoomOut(e);\n              return self.cancelEvent(e);\n            };\n\n            self.bind(self.win, \"gestureend\", self.ongesturezoom);\n          }\n        } // init HORIZ\n\n\n        self.railh = false;\n        var railh;\n\n        if (opt.horizrailenabled) {\n          self.css(cont, {\n            overflowX: 'hidden'\n          });\n          cursor = $(_doc.createElement('div'));\n          cursor.css({\n            position: \"absolute\",\n            top: 0,\n            height: opt.cursorwidth,\n            width: 0,\n            backgroundColor: opt.cursorcolor,\n            border: opt.cursorborder,\n            backgroundClip: 'padding-box',\n            '-webkit-border-radius': opt.cursorborderradius,\n            '-moz-border-radius': opt.cursorborderradius,\n            'border-radius': opt.cursorborderradius\n          });\n          if (cap.isieold) cursor.css('overflow', 'hidden'); //IE6 horiz scrollbar issue\n\n          cursor.addClass('nicescroll-cursors');\n          self.cursorh = cursor;\n          railh = $(_doc.createElement('div'));\n          railh.attr('id', self.id + '-hr');\n          railh.addClass('nicescroll-rails nicescroll-rails-hr');\n          railh.height = Math.max(parseFloat(opt.cursorwidth), cursor.outerHeight());\n          railh.css({\n            height: railh.height + \"px\",\n            'zIndex': self.zindex,\n            \"background\": opt.background\n          });\n          railh.append(cursor);\n          railh.visibility = true;\n          railh.scrollable = true;\n          railh.align = opt.railvalign == \"top\" ? 0 : 1;\n          self.railh = railh;\n          self.railh.drag = false;\n        }\n\n        if (self.ispage) {\n          rail.css({\n            position: \"fixed\",\n            top: 0,\n            height: \"100%\"\n          });\n          rail.css(rail.align ? {\n            right: 0\n          } : {\n            left: 0\n          });\n          self.body.append(rail);\n\n          if (self.railh) {\n            railh.css({\n              position: \"fixed\",\n              left: 0,\n              width: \"100%\"\n            });\n            railh.css(railh.align ? {\n              bottom: 0\n            } : {\n              top: 0\n            });\n            self.body.append(railh);\n          }\n        } else {\n          if (self.ishwscroll) {\n            if (self.win.css('position') == 'static') self.css(self.win, {\n              'position': 'relative'\n            });\n            var bd = self.win[0].nodeName == 'HTML' ? self.body : self.win;\n            $(bd).scrollTop(0).scrollLeft(0); // fix rail position if content already scrolled\n\n            if (self.zoom) {\n              self.zoom.css({\n                position: \"absolute\",\n                top: 1,\n                right: 0,\n                \"margin-right\": rail.width + 4\n              });\n              bd.append(self.zoom);\n            }\n\n            rail.css({\n              position: \"absolute\",\n              top: 0\n            });\n            rail.css(rail.align ? {\n              right: 0\n            } : {\n              left: 0\n            });\n            bd.append(rail);\n\n            if (railh) {\n              railh.css({\n                position: \"absolute\",\n                left: 0,\n                bottom: 0\n              });\n              railh.css(railh.align ? {\n                bottom: 0\n              } : {\n                top: 0\n              });\n              bd.append(railh);\n            }\n          } else {\n            self.isfixed = self.win.css(\"position\") == \"fixed\";\n            var rlpos = self.isfixed ? \"fixed\" : \"absolute\";\n            if (!self.isfixed) self.viewport = self.getViewport(self.win[0]);\n\n            if (self.viewport) {\n              self.body = self.viewport;\n              if (!/fixed|absolute/.test(self.viewport.css(\"position\"))) self.css(self.viewport, {\n                \"position\": \"relative\"\n              });\n            }\n\n            rail.css({\n              position: rlpos\n            });\n            if (self.zoom) self.zoom.css({\n              position: rlpos\n            });\n            self.updateScrollBar();\n            self.body.append(rail);\n            if (self.zoom) self.body.append(self.zoom);\n\n            if (self.railh) {\n              railh.css({\n                position: rlpos\n              });\n              self.body.append(railh);\n            }\n          }\n\n          if (cap.isios) self.css(self.win, {\n            '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\n            '-webkit-touch-callout': 'none'\n          }); // prevent grey layer on click\n\n          if (opt.disableoutline) {\n            if (cap.isie) self.win.attr(\"hideFocus\", \"true\"); // IE, prevent dotted rectangle on focused div\n\n            if (cap.iswebkit) self.win.css('outline', 'none'); // Webkit outline\n          }\n        }\n\n        if (opt.autohidemode === false) {\n          self.autohidedom = false;\n          self.rail.css({\n            opacity: opt.cursoropacitymax\n          });\n          if (self.railh) self.railh.css({\n            opacity: opt.cursoropacitymax\n          });\n        } else if (opt.autohidemode === true || opt.autohidemode === \"leave\") {\n          self.autohidedom = $().add(self.rail);\n          if (cap.isie8) self.autohidedom = self.autohidedom.add(self.cursor);\n          if (self.railh) self.autohidedom = self.autohidedom.add(self.railh);\n          if (self.railh && cap.isie8) self.autohidedom = self.autohidedom.add(self.cursorh);\n        } else if (opt.autohidemode == \"scroll\") {\n          self.autohidedom = $().add(self.rail);\n          if (self.railh) self.autohidedom = self.autohidedom.add(self.railh);\n        } else if (opt.autohidemode == \"cursor\") {\n          self.autohidedom = $().add(self.cursor);\n          if (self.railh) self.autohidedom = self.autohidedom.add(self.cursorh);\n        } else if (opt.autohidemode == \"hidden\") {\n          self.autohidedom = false;\n          self.hide();\n          self.railslocked = false;\n        }\n\n        if (cap.cantouch || self.istouchcapable || opt.emulatetouch || cap.hasmstouch) {\n          self.scrollmom = new ScrollMomentumClass2D(self);\n          var delayedclick = null;\n\n          self.ontouchstart = function (e) {\n            if (self.locked) return false; //if (e.pointerType && e.pointerType != 2 && e.pointerType != \"touch\") return false;\n\n            if (e.pointerType && (e.pointerType === 'mouse' || e.pointerType === e.MSPOINTER_TYPE_MOUSE)) return false; // need test on surface!!\n\n            self.hasmoving = false;\n\n            if (self.scrollmom.timer) {\n              self.triggerScrollEnd();\n              self.scrollmom.stop();\n            }\n\n            if (!self.railslocked) {\n              var tg = self.getTarget(e);\n\n              if (tg) {\n                var skp = /INPUT/i.test(tg.nodeName) && /range/i.test(tg.type);\n                if (skp) return self.stopPropagation(e);\n              }\n\n              var ismouse = e.type === \"mousedown\";\n\n              if (!(\"clientX\" in e) && \"changedTouches\" in e) {\n                e.clientX = e.changedTouches[0].clientX;\n                e.clientY = e.changedTouches[0].clientY;\n              }\n\n              if (self.forcescreen) {\n                var le = e;\n                e = {\n                  \"original\": e.original ? e.original : e\n                };\n                e.clientX = le.screenX;\n                e.clientY = le.screenY;\n              }\n\n              self.rail.drag = {\n                x: e.clientX,\n                y: e.clientY,\n                sx: self.scroll.x,\n                sy: self.scroll.y,\n                st: self.getScrollTop(),\n                sl: self.getScrollLeft(),\n                pt: 2,\n                dl: false,\n                tg: tg\n              };\n\n              if (self.ispage || !opt.directionlockdeadzone) {\n                self.rail.drag.dl = \"f\";\n              } else {\n                var view = {\n                  w: $window.width(),\n                  h: $window.height()\n                };\n                var page = self.getContentSize();\n                var maxh = page.h - view.h;\n                var maxw = page.w - view.w;\n                if (self.rail.scrollable && !self.railh.scrollable) self.rail.drag.ck = maxh > 0 ? \"v\" : false;else if (!self.rail.scrollable && self.railh.scrollable) self.rail.drag.ck = maxw > 0 ? \"h\" : false;else self.rail.drag.ck = false;\n              }\n\n              if (opt.emulatetouch && self.isiframe && cap.isie) {\n                var wp = self.win.position();\n                self.rail.drag.x += wp.left;\n                self.rail.drag.y += wp.top;\n              }\n\n              self.hasmoving = false;\n              self.lastmouseup = false;\n              self.scrollmom.reset(e.clientX, e.clientY);\n\n              if (tg && ismouse) {\n                var ip = /INPUT|SELECT|BUTTON|TEXTAREA/i.test(tg.nodeName);\n\n                if (!ip) {\n                  if (cap.hasmousecapture) tg.setCapture();\n\n                  if (opt.emulatetouch) {\n                    if (tg.onclick && !(tg._onclick || false)) {\n                      // intercept DOM0 onclick event\n                      tg._onclick = tg.onclick;\n\n                      tg.onclick = function (e) {\n                        if (self.hasmoving) return false;\n\n                        tg._onclick.call(this, e);\n                      };\n                    }\n\n                    return self.cancelEvent(e);\n                  }\n\n                  return self.stopPropagation(e);\n                }\n\n                if (/SUBMIT|CANCEL|BUTTON/i.test($(tg).attr('type'))) {\n                  self.preventclick = {\n                    \"tg\": tg,\n                    \"click\": false\n                  };\n                }\n              }\n            }\n          };\n\n          self.ontouchend = function (e) {\n            if (!self.rail.drag) return true;\n\n            if (self.rail.drag.pt == 2) {\n              //if (e.pointerType && e.pointerType != 2 && e.pointerType != \"touch\") return false;\n              if (e.pointerType && (e.pointerType === 'mouse' || e.pointerType === e.MSPOINTER_TYPE_MOUSE)) return false;\n              self.rail.drag = false;\n              var ismouse = e.type === \"mouseup\";\n\n              if (self.hasmoving) {\n                self.scrollmom.doMomentum();\n                self.lastmouseup = true;\n                self.hideCursor();\n                if (cap.hasmousecapture) _doc.releaseCapture();\n                if (ismouse) return self.cancelEvent(e);\n              }\n            } else if (self.rail.drag.pt == 1) {\n              return self.onmouseup(e);\n            }\n          };\n\n          var moveneedoffset = opt.emulatetouch && self.isiframe && !cap.hasmousecapture;\n          var locktollerance = opt.directionlockdeadzone * 0.3 | 0;\n\n          self.ontouchmove = function (e, byiframe) {\n            if (!self.rail.drag) return true;\n\n            if (e.targetTouches && opt.preventmultitouchscrolling) {\n              if (e.targetTouches.length > 1) return true; // multitouch\n            } //if (e.pointerType && e.pointerType != 2 && e.pointerType != \"touch\") return false;\n\n\n            if (e.pointerType && (e.pointerType === 'mouse' || e.pointerType === e.MSPOINTER_TYPE_MOUSE)) return true;\n\n            if (self.rail.drag.pt == 2) {\n              if (\"changedTouches\" in e) {\n                e.clientX = e.changedTouches[0].clientX;\n                e.clientY = e.changedTouches[0].clientY;\n              }\n\n              var ofy, ofx;\n              ofx = ofy = 0;\n\n              if (moveneedoffset && !byiframe) {\n                var wp = self.win.position();\n                ofx = -wp.left;\n                ofy = -wp.top;\n              }\n\n              var fy = e.clientY + ofy;\n              var my = fy - self.rail.drag.y;\n              var fx = e.clientX + ofx;\n              var mx = fx - self.rail.drag.x;\n              var ny = self.rail.drag.st - my;\n\n              if (self.ishwscroll && opt.bouncescroll) {\n                if (ny < 0) {\n                  ny = Math.round(ny / 2);\n                } else if (ny > self.page.maxh) {\n                  ny = self.page.maxh + Math.round((ny - self.page.maxh) / 2);\n                }\n              } else {\n                if (ny < 0) {\n                  ny = 0;\n                  fy = 0;\n                } else if (ny > self.page.maxh) {\n                  ny = self.page.maxh;\n                  fy = 0;\n                }\n\n                if (fy === 0 && !self.hasmoving) {\n                  if (!self.ispage) self.rail.drag = false;\n                  return true;\n                }\n              }\n\n              var nx = self.getScrollLeft();\n\n              if (self.railh && self.railh.scrollable) {\n                nx = self.isrtlmode ? mx - self.rail.drag.sl : self.rail.drag.sl - mx;\n\n                if (self.ishwscroll && opt.bouncescroll) {\n                  if (nx < 0) {\n                    nx = Math.round(nx / 2);\n                  } else if (nx > self.page.maxw) {\n                    nx = self.page.maxw + Math.round((nx - self.page.maxw) / 2);\n                  }\n                } else {\n                  if (nx < 0) {\n                    nx = 0;\n                    fx = 0;\n                  }\n\n                  if (nx > self.page.maxw) {\n                    nx = self.page.maxw;\n                    fx = 0;\n                  }\n                }\n              }\n\n              if (!self.hasmoving) {\n                if (self.rail.drag.y === e.clientY && self.rail.drag.x === e.clientX) return self.cancelEvent(e); // prevent first useless move event \n\n                var ay = Math.abs(my);\n                var ax = Math.abs(mx);\n                var dz = opt.directionlockdeadzone;\n\n                if (!self.rail.drag.ck) {\n                  if (ay > dz && ax > dz) self.rail.drag.dl = \"f\";else if (ay > dz) self.rail.drag.dl = ax > locktollerance ? \"f\" : \"v\";else if (ax > dz) self.rail.drag.dl = ay > locktollerance ? \"f\" : \"h\";\n                } else if (self.rail.drag.ck == \"v\") {\n                  if (ax > dz && ay <= locktollerance) {\n                    self.rail.drag = false;\n                  } else if (ay > dz) self.rail.drag.dl = \"v\";\n                } else if (self.rail.drag.ck == \"h\") {\n                  if (ay > dz && ax <= locktollerance) {\n                    self.rail.drag = false;\n                  } else if (ax > dz) self.rail.drag.dl = \"h\";\n                }\n\n                if (!self.rail.drag.dl) return self.cancelEvent(e);\n                self.triggerScrollStart(e.clientX, e.clientY, 0, 0, 0);\n                self.hasmoving = true;\n              }\n\n              if (self.preventclick && !self.preventclick.click) {\n                self.preventclick.click = self.preventclick.tg.onclick || false;\n                self.preventclick.tg.onclick = self.onpreventclick;\n              }\n\n              if (self.rail.drag.dl) {\n                if (self.rail.drag.dl == \"v\") nx = self.rail.drag.sl;else if (self.rail.drag.dl == \"h\") ny = self.rail.drag.st;\n              }\n\n              self.synched(\"touchmove\", function () {\n                if (self.rail.drag && self.rail.drag.pt == 2) {\n                  if (self.prepareTransition) self.resetTransition();\n                  if (self.rail.scrollable) self.setScrollTop(ny);\n                  self.scrollmom.update(fx, fy);\n\n                  if (self.railh && self.railh.scrollable) {\n                    self.setScrollLeft(nx);\n                    self.showCursor(ny, nx);\n                  } else {\n                    self.showCursor(ny);\n                  }\n\n                  if (cap.isie10) _doc.selection.clear();\n                }\n              });\n              return self.cancelEvent(e);\n            } else if (self.rail.drag.pt == 1) {\n              // drag on cursor\n              return self.onmousemove(e);\n            }\n          };\n\n          self.ontouchstartCursor = function (e, hronly) {\n            if (self.rail.drag && self.rail.drag.pt != 3) return;\n            if (self.locked) return self.cancelEvent(e);\n            self.cancelScroll();\n            self.rail.drag = {\n              x: e.touches[0].clientX,\n              y: e.touches[0].clientY,\n              sx: self.scroll.x,\n              sy: self.scroll.y,\n              pt: 3,\n              hr: !!hronly\n            };\n            var tg = self.getTarget(e);\n            if (!self.ispage && cap.hasmousecapture) tg.setCapture();\n\n            if (self.isiframe && !cap.hasmousecapture) {\n              self.saved.csspointerevents = self.doc.css(\"pointer-events\");\n              self.css(self.doc, {\n                \"pointer-events\": \"none\"\n              });\n            }\n\n            return self.cancelEvent(e);\n          };\n\n          self.ontouchendCursor = function (e) {\n            if (self.rail.drag) {\n              if (cap.hasmousecapture) _doc.releaseCapture();\n              if (self.isiframe && !cap.hasmousecapture) self.doc.css(\"pointer-events\", self.saved.csspointerevents);\n              if (self.rail.drag.pt != 3) return;\n              self.rail.drag = false;\n              return self.cancelEvent(e);\n            }\n          };\n\n          self.ontouchmoveCursor = function (e) {\n            if (self.rail.drag) {\n              if (self.rail.drag.pt != 3) return;\n              self.cursorfreezed = true;\n\n              if (self.rail.drag.hr) {\n                self.scroll.x = self.rail.drag.sx + (e.touches[0].clientX - self.rail.drag.x);\n                if (self.scroll.x < 0) self.scroll.x = 0;\n                var mw = self.scrollvaluemaxw;\n                if (self.scroll.x > mw) self.scroll.x = mw;\n              } else {\n                self.scroll.y = self.rail.drag.sy + (e.touches[0].clientY - self.rail.drag.y);\n                if (self.scroll.y < 0) self.scroll.y = 0;\n                var my = self.scrollvaluemax;\n                if (self.scroll.y > my) self.scroll.y = my;\n              }\n\n              self.synched('touchmove', function () {\n                if (self.rail.drag && self.rail.drag.pt == 3) {\n                  self.showCursor();\n                  if (self.rail.drag.hr) self.doScrollLeft(Math.round(self.scroll.x * self.scrollratio.x), opt.cursordragspeed);else self.doScrollTop(Math.round(self.scroll.y * self.scrollratio.y), opt.cursordragspeed);\n                }\n              });\n              return self.cancelEvent(e);\n            }\n          };\n        }\n\n        self.onmousedown = function (e, hronly) {\n          if (self.rail.drag && self.rail.drag.pt != 1) return;\n          if (self.railslocked) return self.cancelEvent(e);\n          self.cancelScroll();\n          self.rail.drag = {\n            x: e.clientX,\n            y: e.clientY,\n            sx: self.scroll.x,\n            sy: self.scroll.y,\n            pt: 1,\n            hr: hronly || false\n          };\n          var tg = self.getTarget(e);\n          if (cap.hasmousecapture) tg.setCapture();\n\n          if (self.isiframe && !cap.hasmousecapture) {\n            self.saved.csspointerevents = self.doc.css(\"pointer-events\");\n            self.css(self.doc, {\n              \"pointer-events\": \"none\"\n            });\n          }\n\n          self.hasmoving = false;\n          return self.cancelEvent(e);\n        };\n\n        self.onmouseup = function (e) {\n          if (self.rail.drag) {\n            if (self.rail.drag.pt != 1) return true;\n            if (cap.hasmousecapture) _doc.releaseCapture();\n            if (self.isiframe && !cap.hasmousecapture) self.doc.css(\"pointer-events\", self.saved.csspointerevents);\n            self.rail.drag = false;\n            self.cursorfreezed = false;\n            if (self.hasmoving) self.triggerScrollEnd();\n            return self.cancelEvent(e);\n          }\n        };\n\n        self.onmousemove = function (e) {\n          if (self.rail.drag) {\n            if (self.rail.drag.pt !== 1) return;\n            if (cap.ischrome && e.which === 0) return self.onmouseup(e);\n            self.cursorfreezed = true;\n            if (!self.hasmoving) self.triggerScrollStart(e.clientX, e.clientY, 0, 0, 0);\n            self.hasmoving = true;\n\n            if (self.rail.drag.hr) {\n              self.scroll.x = self.rail.drag.sx + (e.clientX - self.rail.drag.x);\n              if (self.scroll.x < 0) self.scroll.x = 0;\n              var mw = self.scrollvaluemaxw;\n              if (self.scroll.x > mw) self.scroll.x = mw;\n            } else {\n              self.scroll.y = self.rail.drag.sy + (e.clientY - self.rail.drag.y);\n              if (self.scroll.y < 0) self.scroll.y = 0;\n              var my = self.scrollvaluemax;\n              if (self.scroll.y > my) self.scroll.y = my;\n            }\n\n            self.synched('mousemove', function () {\n              if (self.cursorfreezed) {\n                self.showCursor();\n\n                if (self.rail.drag.hr) {\n                  self.scrollLeft(Math.round(self.scroll.x * self.scrollratio.x));\n                } else {\n                  self.scrollTop(Math.round(self.scroll.y * self.scrollratio.y));\n                }\n              }\n            });\n            return self.cancelEvent(e);\n          } else {\n            self.checkarea = 0;\n          }\n        };\n\n        if (cap.cantouch || opt.emulatetouch) {\n          self.onpreventclick = function (e) {\n            if (self.preventclick) {\n              self.preventclick.tg.onclick = self.preventclick.click;\n              self.preventclick = false;\n              return self.cancelEvent(e);\n            }\n          };\n\n          self.onclick = cap.isios ? false : function (e) {\n            // it needs to check IE11 ???\n            if (self.lastmouseup) {\n              self.lastmouseup = false;\n              return self.cancelEvent(e);\n            } else {\n              return true;\n            }\n          };\n\n          if (opt.grabcursorenabled && cap.cursorgrabvalue) {\n            self.css(self.ispage ? self.doc : self.win, {\n              'cursor': cap.cursorgrabvalue\n            });\n            self.css(self.rail, {\n              'cursor': cap.cursorgrabvalue\n            });\n          }\n        } else {\n          var checkSelectionScroll = function (e) {\n            if (!self.selectiondrag) return;\n\n            if (e) {\n              var ww = self.win.outerHeight();\n              var df = e.pageY - self.selectiondrag.top;\n              if (df > 0 && df < ww) df = 0;\n              if (df >= ww) df -= ww;\n              self.selectiondrag.df = df;\n            }\n\n            if (self.selectiondrag.df === 0) return;\n            var rt = -(self.selectiondrag.df * 2 / 6) | 0;\n            self.doScrollBy(rt);\n            self.debounced(\"doselectionscroll\", function () {\n              checkSelectionScroll();\n            }, 50);\n          };\n\n          if (\"getSelection\" in _doc) {\n            // A grade - Major browsers\n            self.hasTextSelected = function () {\n              return _doc.getSelection().rangeCount > 0;\n            };\n          } else if (\"selection\" in _doc) {\n            //IE9-\n            self.hasTextSelected = function () {\n              return _doc.selection.type != \"None\";\n            };\n          } else {\n            self.hasTextSelected = function () {\n              // no support\n              return false;\n            };\n          }\n\n          self.onselectionstart = function (e) {\n            //  More testing - severe chrome issues           \n\n            /* \r\n                          if (!self.haswrapper&&(e.which&&e.which==2)) {  // fool browser to manage middle button scrolling\r\n                            self.win.css({'overflow':'auto'});\r\n                            setTimeout(function(){\r\n                              self.win.css({'overflow':'hidden'});\r\n                            },10);                \r\n                            return true;\r\n                          }            \r\n            */\n            if (self.ispage) return;\n            self.selectiondrag = self.win.offset();\n          };\n\n          self.onselectionend = function (e) {\n            self.selectiondrag = false;\n          };\n\n          self.onselectiondrag = function (e) {\n            if (!self.selectiondrag) return;\n            if (self.hasTextSelected()) self.debounced(\"selectionscroll\", function () {\n              checkSelectionScroll(e);\n            }, 250);\n          };\n        }\n\n        if (cap.hasw3ctouch) {\n          //IE11+\n          self.css(self.ispage ? $(\"html\") : self.win, {\n            'touch-action': 'none'\n          });\n          self.css(self.rail, {\n            'touch-action': 'none'\n          });\n          self.css(self.cursor, {\n            'touch-action': 'none'\n          });\n          self.bind(self.win, \"pointerdown\", self.ontouchstart);\n          self.bind(_doc, \"pointerup\", self.ontouchend);\n          self.delegate(_doc, \"pointermove\", self.ontouchmove);\n        } else if (cap.hasmstouch) {\n          //IE10\n          self.css(self.ispage ? $(\"html\") : self.win, {\n            '-ms-touch-action': 'none'\n          });\n          self.css(self.rail, {\n            '-ms-touch-action': 'none'\n          });\n          self.css(self.cursor, {\n            '-ms-touch-action': 'none'\n          });\n          self.bind(self.win, \"MSPointerDown\", self.ontouchstart);\n          self.bind(_doc, \"MSPointerUp\", self.ontouchend);\n          self.delegate(_doc, \"MSPointerMove\", self.ontouchmove);\n          self.bind(self.cursor, \"MSGestureHold\", function (e) {\n            e.preventDefault();\n          });\n          self.bind(self.cursor, \"contextmenu\", function (e) {\n            e.preventDefault();\n          });\n        } else if (cap.cantouch) {\n          // smartphones/touch devices\n          self.bind(self.win, \"touchstart\", self.ontouchstart, false, true);\n          self.bind(_doc, \"touchend\", self.ontouchend, false, true);\n          self.bind(_doc, \"touchcancel\", self.ontouchend, false, true);\n          self.delegate(_doc, \"touchmove\", self.ontouchmove, false, true);\n        }\n\n        if (opt.emulatetouch) {\n          self.bind(self.win, \"mousedown\", self.ontouchstart, false, true);\n          self.bind(_doc, \"mouseup\", self.ontouchend, false, true);\n          self.bind(_doc, \"mousemove\", self.ontouchmove, false, true);\n        }\n\n        if (opt.cursordragontouch || !cap.cantouch && !opt.emulatetouch) {\n          self.rail.css({\n            cursor: \"default\"\n          });\n          self.railh && self.railh.css({\n            cursor: \"default\"\n          });\n          self.jqbind(self.rail, \"mouseenter\", function () {\n            if (!self.ispage && !self.win.is(\":visible\")) return false;\n            if (self.canshowonmouseevent) self.showCursor();\n            self.rail.active = true;\n          });\n          self.jqbind(self.rail, \"mouseleave\", function () {\n            self.rail.active = false;\n            if (!self.rail.drag) self.hideCursor();\n          });\n\n          if (opt.sensitiverail) {\n            self.bind(self.rail, \"click\", function (e) {\n              self.doRailClick(e, false, false);\n            });\n            self.bind(self.rail, \"dblclick\", function (e) {\n              self.doRailClick(e, true, false);\n            });\n            self.bind(self.cursor, \"click\", function (e) {\n              self.cancelEvent(e);\n            });\n            self.bind(self.cursor, \"dblclick\", function (e) {\n              self.cancelEvent(e);\n            });\n          }\n\n          if (self.railh) {\n            self.jqbind(self.railh, \"mouseenter\", function () {\n              if (!self.ispage && !self.win.is(\":visible\")) return false;\n              if (self.canshowonmouseevent) self.showCursor();\n              self.rail.active = true;\n            });\n            self.jqbind(self.railh, \"mouseleave\", function () {\n              self.rail.active = false;\n              if (!self.rail.drag) self.hideCursor();\n            });\n\n            if (opt.sensitiverail) {\n              self.bind(self.railh, \"click\", function (e) {\n                self.doRailClick(e, false, true);\n              });\n              self.bind(self.railh, \"dblclick\", function (e) {\n                self.doRailClick(e, true, true);\n              });\n              self.bind(self.cursorh, \"click\", function (e) {\n                self.cancelEvent(e);\n              });\n              self.bind(self.cursorh, \"dblclick\", function (e) {\n                self.cancelEvent(e);\n              });\n            }\n          }\n        }\n\n        if (opt.cursordragontouch && (this.istouchcapable || cap.cantouch)) {\n          self.bind(self.cursor, \"touchstart\", self.ontouchstartCursor);\n          self.bind(self.cursor, \"touchmove\", self.ontouchmoveCursor);\n          self.bind(self.cursor, \"touchend\", self.ontouchendCursor);\n          self.cursorh && self.bind(self.cursorh, \"touchstart\", function (e) {\n            self.ontouchstartCursor(e, true);\n          });\n          self.cursorh && self.bind(self.cursorh, \"touchmove\", self.ontouchmoveCursor);\n          self.cursorh && self.bind(self.cursorh, \"touchend\", self.ontouchendCursor);\n        } //        if (!cap.cantouch && !opt.emulatetouch) {\n\n\n        if (!opt.emulatetouch && !cap.isandroid && !cap.isios) {\n          self.bind(cap.hasmousecapture ? self.win : _doc, \"mouseup\", self.onmouseup);\n          self.bind(_doc, \"mousemove\", self.onmousemove);\n          if (self.onclick) self.bind(_doc, \"click\", self.onclick);\n          self.bind(self.cursor, \"mousedown\", self.onmousedown);\n          self.bind(self.cursor, \"mouseup\", self.onmouseup);\n\n          if (self.railh) {\n            self.bind(self.cursorh, \"mousedown\", function (e) {\n              self.onmousedown(e, true);\n            });\n            self.bind(self.cursorh, \"mouseup\", self.onmouseup);\n          }\n\n          if (!self.ispage && opt.enablescrollonselection) {\n            self.bind(self.win[0], \"mousedown\", self.onselectionstart);\n            self.bind(_doc, \"mouseup\", self.onselectionend);\n            self.bind(self.cursor, \"mouseup\", self.onselectionend);\n            if (self.cursorh) self.bind(self.cursorh, \"mouseup\", self.onselectionend);\n            self.bind(_doc, \"mousemove\", self.onselectiondrag);\n          }\n\n          if (self.zoom) {\n            self.jqbind(self.zoom, \"mouseenter\", function () {\n              if (self.canshowonmouseevent) self.showCursor();\n              self.rail.active = true;\n            });\n            self.jqbind(self.zoom, \"mouseleave\", function () {\n              self.rail.active = false;\n              if (!self.rail.drag) self.hideCursor();\n            });\n          }\n        } else {\n          self.bind(cap.hasmousecapture ? self.win : _doc, \"mouseup\", self.ontouchend);\n          if (self.onclick) self.bind(_doc, \"click\", self.onclick);\n\n          if (opt.cursordragontouch) {\n            self.bind(self.cursor, \"mousedown\", self.onmousedown);\n            self.bind(self.cursor, \"mouseup\", self.onmouseup);\n            self.cursorh && self.bind(self.cursorh, \"mousedown\", function (e) {\n              self.onmousedown(e, true);\n            });\n            self.cursorh && self.bind(self.cursorh, \"mouseup\", self.onmouseup);\n          } else {\n            self.bind(self.rail, \"mousedown\", function (e) {\n              e.preventDefault();\n            }); // prevent text selection             \n\n            self.railh && self.bind(self.railh, \"mousedown\", function (e) {\n              e.preventDefault();\n            });\n          }\n        }\n\n        if (opt.enablemousewheel) {\n          if (!self.isiframe) self.mousewheel(cap.isie && self.ispage ? _doc : self.win, self.onmousewheel);\n          self.mousewheel(self.rail, self.onmousewheel);\n          if (self.railh) self.mousewheel(self.railh, self.onmousewheelhr);\n        }\n\n        if (!self.ispage && !cap.cantouch && !/HTML|^BODY/.test(self.win[0].nodeName)) {\n          if (!self.win.attr(\"tabindex\")) self.win.attr({\n            \"tabindex\": ++tabindexcounter\n          });\n          self.bind(self.win, \"focus\", function (e) {\n            // better using native events\n            domfocus = self.getTarget(e).id || self.getTarget(e) || false;\n            self.hasfocus = true;\n            if (self.canshowonmouseevent) self.noticeCursor();\n          });\n          self.bind(self.win, \"blur\", function (e) {\n            // *\n            domfocus = false;\n            self.hasfocus = false;\n          });\n          self.bind(self.win, \"mouseenter\", function (e) {\n            // *\n            mousefocus = self.getTarget(e).id || self.getTarget(e) || false;\n            self.hasmousefocus = true;\n            if (self.canshowonmouseevent) self.noticeCursor();\n          });\n          self.bind(self.win, \"mouseleave\", function (e) {\n            // *       \n            mousefocus = false;\n            self.hasmousefocus = false;\n            if (!self.rail.drag) self.hideCursor();\n          });\n        } //Thanks to http://www.quirksmode.org !!\n\n\n        self.onkeypress = function (e) {\n          if (self.railslocked && self.page.maxh === 0) return true;\n          e = e || _win.event;\n          var tg = self.getTarget(e);\n\n          if (tg && /INPUT|TEXTAREA|SELECT|OPTION/.test(tg.nodeName)) {\n            var tp = tg.getAttribute('type') || tg.type || false;\n            if (!tp || !/submit|button|cancel/i.tp) return true;\n          }\n\n          if ($(tg).attr('contenteditable')) return true;\n\n          if (self.hasfocus || self.hasmousefocus && !domfocus || self.ispage && !domfocus && !mousefocus) {\n            var key = e.keyCode;\n            if (self.railslocked && key != 27) return self.cancelEvent(e);\n            var ctrl = e.ctrlKey || false;\n            var shift = e.shiftKey || false;\n            var ret = false;\n\n            switch (key) {\n              case 38:\n              case 63233:\n                //safari\n                self.doScrollBy(24 * 3);\n                ret = true;\n                break;\n\n              case 40:\n              case 63235:\n                //safari\n                self.doScrollBy(-24 * 3);\n                ret = true;\n                break;\n\n              case 37:\n              case 63232:\n                //safari\n                if (self.railh) {\n                  ctrl ? self.doScrollLeft(0) : self.doScrollLeftBy(24 * 3);\n                  ret = true;\n                }\n\n                break;\n\n              case 39:\n              case 63234:\n                //safari\n                if (self.railh) {\n                  ctrl ? self.doScrollLeft(self.page.maxw) : self.doScrollLeftBy(-24 * 3);\n                  ret = true;\n                }\n\n                break;\n\n              case 33:\n              case 63276:\n                // safari\n                self.doScrollBy(self.view.h);\n                ret = true;\n                break;\n\n              case 34:\n              case 63277:\n                // safari\n                self.doScrollBy(-self.view.h);\n                ret = true;\n                break;\n\n              case 36:\n              case 63273:\n                // safari                \n                self.railh && ctrl ? self.doScrollPos(0, 0) : self.doScrollTo(0);\n                ret = true;\n                break;\n\n              case 35:\n              case 63275:\n                // safari\n                self.railh && ctrl ? self.doScrollPos(self.page.maxw, self.page.maxh) : self.doScrollTo(self.page.maxh);\n                ret = true;\n                break;\n\n              case 32:\n                if (opt.spacebarenabled) {\n                  shift ? self.doScrollBy(self.view.h) : self.doScrollBy(-self.view.h);\n                  ret = true;\n                }\n\n                break;\n\n              case 27:\n                // ESC\n                if (self.zoomactive) {\n                  self.doZoom();\n                  ret = true;\n                }\n\n                break;\n            }\n\n            if (ret) return self.cancelEvent(e);\n          }\n        };\n\n        if (opt.enablekeyboard) self.bind(_doc, cap.isopera && !cap.isopera12 ? \"keypress\" : \"keydown\", self.onkeypress);\n        self.bind(_doc, \"keydown\", function (e) {\n          var ctrl = e.ctrlKey || false;\n          if (ctrl) self.wheelprevented = true;\n        });\n        self.bind(_doc, \"keyup\", function (e) {\n          var ctrl = e.ctrlKey || false;\n          if (!ctrl) self.wheelprevented = false;\n        });\n        self.bind(_win, \"blur\", function (e) {\n          self.wheelprevented = false;\n        });\n        self.bind(_win, 'resize', self.onscreenresize);\n        self.bind(_win, 'orientationchange', self.onscreenresize);\n        self.bind(_win, \"load\", self.lazyResize);\n\n        if (cap.ischrome && !self.ispage && !self.haswrapper) {\n          //chrome void scrollbar bug - it persists in version 26\n          var tmp = self.win.attr(\"style\");\n          var ww = parseFloat(self.win.css(\"width\")) + 1;\n          self.win.css('width', ww);\n          self.synched(\"chromefix\", function () {\n            self.win.attr(\"style\", tmp);\n          });\n        } // Trying a cross-browser implementation - good luck!\n\n\n        self.onAttributeChange = function (e) {\n          self.lazyResize(self.isieold ? 250 : 30);\n        };\n\n        if (opt.enableobserver) {\n          if (!self.isie11 && ClsMutationObserver !== false) {\n            // IE11 crashes  #568\n            self.observerbody = new ClsMutationObserver(function (mutations) {\n              mutations.forEach(function (mut) {\n                if (mut.type == \"attributes\") {\n                  return $body.hasClass(\"modal-open\") && $body.hasClass(\"modal-dialog\") && !$.contains($('.modal-dialog')[0], self.doc[0]) ? self.hide() : self.show(); // Support for Bootstrap modal; Added check if the nice scroll element is inside a modal\n                }\n              });\n              if (self.me.clientWidth != self.page.width || self.me.clientHeight != self.page.height) return self.lazyResize(30);\n            });\n            self.observerbody.observe(_doc.body, {\n              childList: true,\n              subtree: true,\n              characterData: false,\n              attributes: true,\n              attributeFilter: ['class']\n            });\n          }\n\n          if (!self.ispage && !self.haswrapper) {\n            var _dom = self.win[0]; // redesigned MutationObserver for Chrome18+/Firefox14+/iOS6+ with support for: remove div, add/remove content\n\n            if (ClsMutationObserver !== false) {\n              self.observer = new ClsMutationObserver(function (mutations) {\n                mutations.forEach(self.onAttributeChange);\n              });\n              self.observer.observe(_dom, {\n                childList: true,\n                characterData: false,\n                attributes: true,\n                subtree: false\n              });\n              self.observerremover = new ClsMutationObserver(function (mutations) {\n                mutations.forEach(function (mo) {\n                  if (mo.removedNodes.length > 0) {\n                    for (var dd in mo.removedNodes) {\n                      if (!!self && mo.removedNodes[dd] === _dom) return self.remove();\n                    }\n                  }\n                });\n              });\n              self.observerremover.observe(_dom.parentNode, {\n                childList: true,\n                characterData: false,\n                attributes: false,\n                subtree: false\n              });\n            } else {\n              self.bind(_dom, cap.isie && !cap.isie9 ? \"propertychange\" : \"DOMAttrModified\", self.onAttributeChange);\n              if (cap.isie9) _dom.attachEvent(\"onpropertychange\", self.onAttributeChange); //IE9 DOMAttrModified bug\n\n              self.bind(_dom, \"DOMNodeRemoved\", function (e) {\n                if (e.target === _dom) self.remove();\n              });\n            }\n          }\n        } //\n\n\n        if (!self.ispage && opt.boxzoom) self.bind(_win, \"resize\", self.resizeZoom);\n\n        if (self.istextarea) {\n          self.bind(self.win, \"keydown\", self.lazyResize);\n          self.bind(self.win, \"mouseup\", self.lazyResize);\n        }\n\n        self.lazyResize(30);\n      }\n\n      if (this.doc[0].nodeName == 'IFRAME') {\n        var oniframeload = function () {\n          self.iframexd = false;\n          var doc;\n\n          try {\n            doc = 'contentDocument' in this ? this.contentDocument : this.contentWindow._doc;\n            var a = doc.domain;\n          } catch (e) {\n            self.iframexd = true;\n            doc = false;\n          }\n\n          if (self.iframexd) {\n            if (\"console\" in _win) console.log('NiceScroll error: policy restriced iframe');\n            return true; //cross-domain - I can't manage this        \n          }\n\n          self.forcescreen = true;\n\n          if (self.isiframe) {\n            self.iframe = {\n              \"doc\": $(doc),\n              \"html\": self.doc.contents().find('html')[0],\n              \"body\": self.doc.contents().find('body')[0]\n            };\n\n            self.getContentSize = function () {\n              return {\n                w: Math.max(self.iframe.html.scrollWidth, self.iframe.body.scrollWidth),\n                h: Math.max(self.iframe.html.scrollHeight, self.iframe.body.scrollHeight)\n              };\n            };\n\n            self.docscroll = $(self.iframe.body);\n          }\n\n          if (!cap.isios && opt.iframeautoresize && !self.isiframe) {\n            self.win.scrollTop(0); // reset position\n\n            self.doc.height(\"\"); //reset height to fix browser bug\n\n            var hh = Math.max(doc.getElementsByTagName('html')[0].scrollHeight, doc.body.scrollHeight);\n            self.doc.height(hh);\n          }\n\n          self.lazyResize(30);\n          self.css($(self.iframe.body), _scrollyhidden);\n\n          if (cap.isios && self.haswrapper) {\n            self.css($(doc.body), {\n              '-webkit-transform': 'translate3d(0,0,0)'\n            }); // avoid iFrame content clipping - thanks to http://blog.derraab.com/2012/04/02/avoid-iframe-content-clipping-with-css-transform-on-ios/\n          }\n\n          if ('contentWindow' in this) {\n            self.bind(this.contentWindow, \"scroll\", self.onscroll); //IE8 & minor\n          } else {\n            self.bind(doc, \"scroll\", self.onscroll);\n          }\n\n          if (opt.enablemousewheel) {\n            self.mousewheel(doc, self.onmousewheel);\n          }\n\n          if (opt.enablekeyboard) self.bind(doc, cap.isopera ? \"keypress\" : \"keydown\", self.onkeypress);\n\n          if (cap.cantouch) {\n            self.bind(doc, \"touchstart\", self.ontouchstart);\n            self.bind(doc, \"touchmove\", self.ontouchmove);\n          } else if (opt.emulatetouch) {\n            self.bind(doc, \"mousedown\", self.ontouchstart);\n            self.bind(doc, \"mousemove\", function (e) {\n              return self.ontouchmove(e, true);\n            });\n            if (opt.grabcursorenabled && cap.cursorgrabvalue) self.css($(doc.body), {\n              'cursor': cap.cursorgrabvalue\n            });\n          }\n\n          self.bind(doc, \"mouseup\", self.ontouchend);\n\n          if (self.zoom) {\n            if (opt.dblclickzoom) self.bind(doc, 'dblclick', self.doZoom);\n            if (self.ongesturezoom) self.bind(doc, \"gestureend\", self.ongesturezoom);\n          }\n        };\n\n        if (this.doc[0].readyState && this.doc[0].readyState === \"complete\") {\n          setTimeout(function () {\n            oniframeload.call(self.doc[0], false);\n          }, 500);\n        }\n\n        self.bind(this.doc, \"load\", oniframeload);\n      }\n    };\n\n    this.showCursor = function (py, px) {\n      if (self.cursortimeout) {\n        clearTimeout(self.cursortimeout);\n        self.cursortimeout = 0;\n      }\n\n      if (!self.rail) return;\n\n      if (self.autohidedom) {\n        self.autohidedom.stop().css({\n          opacity: opt.cursoropacitymax\n        });\n        self.cursoractive = true;\n      }\n\n      if (!self.rail.drag || self.rail.drag.pt != 1) {\n        if (py !== undefined && py !== false) {\n          self.scroll.y = py / self.scrollratio.y | 0;\n        }\n\n        if (px !== undefined) {\n          self.scroll.x = px / self.scrollratio.x | 0;\n        }\n      }\n\n      self.cursor.css({\n        height: self.cursorheight,\n        top: self.scroll.y\n      });\n\n      if (self.cursorh) {\n        var lx = self.hasreversehr ? self.scrollvaluemaxw - self.scroll.x : self.scroll.x;\n        self.cursorh.css({\n          width: self.cursorwidth,\n          left: !self.rail.align && self.rail.visibility ? lx + self.rail.width : lx\n        });\n        self.cursoractive = true;\n      }\n\n      if (self.zoom) self.zoom.stop().css({\n        opacity: opt.cursoropacitymax\n      });\n    };\n\n    this.hideCursor = function (tm) {\n      if (self.cursortimeout) return;\n      if (!self.rail) return;\n      if (!self.autohidedom) return;\n      if (self.hasmousefocus && opt.autohidemode === \"leave\") return;\n      self.cursortimeout = setTimeout(function () {\n        if (!self.rail.active || !self.showonmouseevent) {\n          self.autohidedom.stop().animate({\n            opacity: opt.cursoropacitymin\n          });\n          if (self.zoom) self.zoom.stop().animate({\n            opacity: opt.cursoropacitymin\n          });\n          self.cursoractive = false;\n        }\n\n        self.cursortimeout = 0;\n      }, tm || opt.hidecursordelay);\n    };\n\n    this.noticeCursor = function (tm, py, px) {\n      self.showCursor(py, px);\n      if (!self.rail.active) self.hideCursor(tm);\n    };\n\n    this.getContentSize = self.ispage ? function () {\n      return {\n        w: Math.max(_doc.body.scrollWidth, _doc.documentElement.scrollWidth),\n        h: Math.max(_doc.body.scrollHeight, _doc.documentElement.scrollHeight)\n      };\n    } : self.haswrapper ? function () {\n      return {\n        w: self.doc[0].offsetWidth,\n        h: self.doc[0].offsetHeight\n      };\n    } : function () {\n      return {\n        w: self.docscroll[0].scrollWidth,\n        h: self.docscroll[0].scrollHeight\n      };\n    };\n\n    this.onResize = function (e, page) {\n      if (!self || !self.win) return false;\n      var premaxh = self.page.maxh,\n          premaxw = self.page.maxw,\n          previewh = self.view.h,\n          previeww = self.view.w;\n      self.view = {\n        w: self.ispage ? self.win.width() : self.win[0].clientWidth,\n        h: self.ispage ? self.win.height() : self.win[0].clientHeight\n      };\n      self.page = page ? page : self.getContentSize();\n      self.page.maxh = Math.max(0, self.page.h - self.view.h);\n      self.page.maxw = Math.max(0, self.page.w - self.view.w);\n\n      if (self.page.maxh == premaxh && self.page.maxw == premaxw && self.view.w == previeww && self.view.h == previewh) {\n        // test position        \n        if (!self.ispage) {\n          var pos = self.win.offset();\n\n          if (self.lastposition) {\n            var lst = self.lastposition;\n            if (lst.top == pos.top && lst.left == pos.left) return self; //nothing to do            \n          }\n\n          self.lastposition = pos;\n        } else {\n          return self; //nothing to do\n        }\n      }\n\n      if (self.page.maxh === 0) {\n        self.hideRail();\n        self.scrollvaluemax = 0;\n        self.scroll.y = 0;\n        self.scrollratio.y = 0;\n        self.cursorheight = 0;\n        self.setScrollTop(0);\n        if (self.rail) self.rail.scrollable = false;\n      } else {\n        self.page.maxh -= opt.railpadding.top + opt.railpadding.bottom;\n        self.rail.scrollable = true;\n      }\n\n      if (self.page.maxw === 0) {\n        self.hideRailHr();\n        self.scrollvaluemaxw = 0;\n        self.scroll.x = 0;\n        self.scrollratio.x = 0;\n        self.cursorwidth = 0;\n        self.setScrollLeft(0);\n\n        if (self.railh) {\n          self.railh.scrollable = false;\n        }\n      } else {\n        self.page.maxw -= opt.railpadding.left + opt.railpadding.right;\n        if (self.railh) self.railh.scrollable = opt.horizrailenabled;\n      }\n\n      self.railslocked = self.locked || self.page.maxh === 0 && self.page.maxw === 0;\n\n      if (self.railslocked) {\n        if (!self.ispage) self.updateScrollBar(self.view);\n        return false;\n      }\n\n      if (!self.hidden) {\n        if (!self.rail.visibility) self.showRail();\n        if (self.railh && !self.railh.visibility) self.showRailHr();\n      }\n\n      if (self.istextarea && self.win.css('resize') && self.win.css('resize') != 'none') self.view.h -= 20;\n      self.cursorheight = Math.min(self.view.h, Math.round(self.view.h * (self.view.h / self.page.h)));\n      self.cursorheight = opt.cursorfixedheight ? opt.cursorfixedheight : Math.max(opt.cursorminheight, self.cursorheight);\n      self.cursorwidth = Math.min(self.view.w, Math.round(self.view.w * (self.view.w / self.page.w)));\n      self.cursorwidth = opt.cursorfixedheight ? opt.cursorfixedheight : Math.max(opt.cursorminheight, self.cursorwidth);\n      self.scrollvaluemax = self.view.h - self.cursorheight - (opt.railpadding.top + opt.railpadding.bottom);\n      if (!self.hasborderbox) self.scrollvaluemax -= self.cursor[0].offsetHeight - self.cursor[0].clientHeight;\n\n      if (self.railh) {\n        self.railh.width = self.page.maxh > 0 ? self.view.w - self.rail.width : self.view.w;\n        self.scrollvaluemaxw = self.railh.width - self.cursorwidth - (opt.railpadding.left + opt.railpadding.right);\n      }\n\n      if (!self.ispage) self.updateScrollBar(self.view);\n      self.scrollratio = {\n        x: self.page.maxw / self.scrollvaluemaxw,\n        y: self.page.maxh / self.scrollvaluemax\n      };\n      var sy = self.getScrollTop();\n\n      if (sy > self.page.maxh) {\n        self.doScrollTop(self.page.maxh);\n      } else {\n        self.scroll.y = self.getScrollTop() / self.scrollratio.y | 0;\n        self.scroll.x = self.getScrollLeft() / self.scrollratio.x | 0;\n        if (self.cursoractive) self.noticeCursor();\n      }\n\n      if (self.scroll.y && self.getScrollTop() === 0) self.doScrollTo(self.scroll.y * self.scrollratio.y | 0);\n      return self;\n    };\n\n    this.resize = self.onResize;\n    var hlazyresize = 0;\n\n    this.onscreenresize = function (e) {\n      clearTimeout(hlazyresize);\n      var hiderails = !self.ispage && !self.haswrapper;\n      if (hiderails) self.hideRails();\n      hlazyresize = setTimeout(function () {\n        if (self) {\n          if (hiderails) self.showRails();\n          self.resize();\n        }\n\n        hlazyresize = 0;\n      }, 120);\n    };\n\n    this.lazyResize = function (tm) {\n      // event debounce\n      clearTimeout(hlazyresize);\n      tm = isNaN(tm) ? 240 : tm;\n      hlazyresize = setTimeout(function () {\n        self && self.resize();\n        hlazyresize = 0;\n      }, tm);\n      return self;\n    }; // derived by MDN https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/wheel\n\n\n    function _modernWheelEvent(dom, name, fn, bubble) {\n      self._bind(dom, name, function (e) {\n        e = e || _win.event;\n        var event = {\n          original: e,\n          target: e.target || e.srcElement,\n          type: \"wheel\",\n          deltaMode: e.type == \"MozMousePixelScroll\" ? 0 : 1,\n          deltaX: 0,\n          deltaZ: 0,\n          preventDefault: function () {\n            e.preventDefault ? e.preventDefault() : e.returnValue = false;\n            return false;\n          },\n          stopImmediatePropagation: function () {\n            e.stopImmediatePropagation ? e.stopImmediatePropagation() : e.cancelBubble = true;\n          }\n        };\n\n        if (name == \"mousewheel\") {\n          e.wheelDeltaX && (event.deltaX = -1 / 40 * e.wheelDeltaX);\n          e.wheelDeltaY && (event.deltaY = -1 / 40 * e.wheelDeltaY);\n          !event.deltaY && !event.deltaX && (event.deltaY = -1 / 40 * e.wheelDelta);\n        } else {\n          event.deltaY = e.detail;\n        }\n\n        return fn.call(dom, event);\n      }, bubble);\n    }\n\n    this.jqbind = function (dom, name, fn) {\n      // use jquery bind for non-native events (mouseenter/mouseleave)\n      self.events.push({\n        e: dom,\n        n: name,\n        f: fn,\n        q: true\n      });\n      $(dom).on(name, fn);\n    };\n\n    this.mousewheel = function (dom, fn, bubble) {\n      // bind mousewheel\n      var el = \"jquery\" in dom ? dom[0] : dom;\n\n      if (\"onwheel\" in _doc.createElement(\"div\")) {\n        // Modern browsers support \"wheel\"\n        self._bind(el, \"wheel\", fn, bubble || false);\n      } else {\n        var wname = _doc.onmousewheel !== undefined ? \"mousewheel\" : \"DOMMouseScroll\"; // older Webkit+IE support or older Firefox          \n\n        _modernWheelEvent(el, wname, fn, bubble || false);\n\n        if (wname == \"DOMMouseScroll\") _modernWheelEvent(el, \"MozMousePixelScroll\", fn, bubble || false); // Firefox legacy\n      }\n    };\n\n    var passiveSupported = false;\n\n    if (cap.haseventlistener) {\n      // W3C standard event model\n      // thanks to https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n      try {\n        var options = Object.defineProperty({}, \"passive\", {\n          get: function () {\n            passiveSupported = !0;\n          }\n        });\n\n        _win.addEventListener(\"test\", null, options);\n      } catch (err) {}\n\n      this.stopPropagation = function (e) {\n        if (!e) return false;\n        e = e.original ? e.original : e;\n        e.stopPropagation();\n        return false;\n      };\n\n      this.cancelEvent = function (e) {\n        if (e.cancelable) e.preventDefault();\n        e.stopImmediatePropagation();\n        if (e.preventManipulation) e.preventManipulation(); // IE10+\n\n        return false;\n      };\n    } else {\n      // inspired from https://gist.github.com/jonathantneal/2415137      \n      Event.prototype.preventDefault = function () {\n        this.returnValue = false;\n      };\n\n      Event.prototype.stopPropagation = function () {\n        this.cancelBubble = true;\n      };\n\n      _win.constructor.prototype.addEventListener = _doc.constructor.prototype.addEventListener = Element.prototype.addEventListener = function (type, listener, useCapture) {\n        this.attachEvent(\"on\" + type, listener);\n      };\n\n      _win.constructor.prototype.removeEventListener = _doc.constructor.prototype.removeEventListener = Element.prototype.removeEventListener = function (type, listener, useCapture) {\n        this.detachEvent(\"on\" + type, listener);\n      }; // Thanks to http://www.switchonthecode.com !!\n\n\n      this.cancelEvent = function (e) {\n        e = e || _win.event;\n\n        if (e) {\n          e.cancelBubble = true;\n          e.cancel = true;\n          e.returnValue = false;\n        }\n\n        return false;\n      };\n\n      this.stopPropagation = function (e) {\n        e = e || _win.event;\n        if (e) e.cancelBubble = true;\n        return false;\n      };\n    }\n\n    this.delegate = function (dom, name, fn, bubble, active) {\n      var de = delegatevents[name] || false;\n\n      if (!de) {\n        de = {\n          a: [],\n          l: [],\n          f: function (e) {\n            var lst = de.l,\n                l = lst.length - 1;\n            var r = false;\n\n            for (var a = l; a >= 0; a--) {\n              r = lst[a].call(e.target, e);\n              if (r === false) return false;\n            }\n\n            return r;\n          }\n        };\n        self.bind(dom, name, de.f, bubble, active);\n        delegatevents[name] = de;\n      }\n\n      if (self.ispage) {\n        de.a = [self.id].concat(de.a);\n        de.l = [fn].concat(de.l);\n      } else {\n        de.a.push(self.id);\n        de.l.push(fn);\n      }\n    };\n\n    this.undelegate = function (dom, name, fn, bubble, active) {\n      var de = delegatevents[name] || false;\n\n      if (de && de.l) {\n        // quick fix #683\n        for (var a = 0, l = de.l.length; a < l; a++) {\n          if (de.a[a] === self.id) {\n            de.a.splice(a);\n            de.l.splice(a);\n\n            if (de.a.length === 0) {\n              self._unbind(dom, name, de.l.f);\n\n              delegatevents[name] = null;\n            }\n          }\n        }\n      }\n    };\n\n    this.bind = function (dom, name, fn, bubble, active) {\n      var el = \"jquery\" in dom ? dom[0] : dom;\n\n      self._bind(el, name, fn, bubble || false, active || false);\n    };\n\n    this._bind = function (el, name, fn, bubble, active) {\n      // primitive bind\n      self.events.push({\n        e: el,\n        n: name,\n        f: fn,\n        b: bubble,\n        q: false\n      });\n      passiveSupported && active ? el.addEventListener(name, fn, {\n        passive: false,\n        capture: bubble\n      }) : el.addEventListener(name, fn, bubble || false);\n    };\n\n    this._unbind = function (el, name, fn, bub) {\n      // primitive unbind\n      if (delegatevents[name]) self.undelegate(el, name, fn, bub);else el.removeEventListener(name, fn, bub);\n    };\n\n    this.unbindAll = function () {\n      for (var a = 0; a < self.events.length; a++) {\n        var r = self.events[a];\n        r.q ? r.e.unbind(r.n, r.f) : self._unbind(r.e, r.n, r.f, r.b);\n      }\n    };\n\n    this.showRails = function () {\n      return self.showRail().showRailHr();\n    };\n\n    this.showRail = function () {\n      if (self.page.maxh !== 0 && (self.ispage || self.win.css('display') != 'none')) {\n        //self.visibility = true;\n        self.rail.visibility = true;\n        self.rail.css('display', 'block');\n      }\n\n      return self;\n    };\n\n    this.showRailHr = function () {\n      if (self.railh) {\n        if (self.page.maxw !== 0 && (self.ispage || self.win.css('display') != 'none')) {\n          self.railh.visibility = true;\n          self.railh.css('display', 'block');\n        }\n      }\n\n      return self;\n    };\n\n    this.hideRails = function () {\n      return self.hideRail().hideRailHr();\n    };\n\n    this.hideRail = function () {\n      //self.visibility = false;\n      self.rail.visibility = false;\n      self.rail.css('display', 'none');\n      return self;\n    };\n\n    this.hideRailHr = function () {\n      if (self.railh) {\n        self.railh.visibility = false;\n        self.railh.css('display', 'none');\n      }\n\n      return self;\n    };\n\n    this.show = function () {\n      self.hidden = false;\n      self.railslocked = false;\n      return self.showRails();\n    };\n\n    this.hide = function () {\n      self.hidden = true;\n      self.railslocked = true;\n      return self.hideRails();\n    };\n\n    this.toggle = function () {\n      return self.hidden ? self.show() : self.hide();\n    };\n\n    this.remove = function () {\n      self.stop();\n      if (self.cursortimeout) clearTimeout(self.cursortimeout);\n\n      for (var n in self.delaylist) if (self.delaylist[n]) clearAnimationFrame(self.delaylist[n].h);\n\n      self.doZoomOut();\n      self.unbindAll();\n      if (cap.isie9) self.win[0].detachEvent(\"onpropertychange\", self.onAttributeChange); //IE9 DOMAttrModified bug\n\n      if (self.observer !== false) self.observer.disconnect();\n      if (self.observerremover !== false) self.observerremover.disconnect();\n      if (self.observerbody !== false) self.observerbody.disconnect();\n      self.events = null;\n\n      if (self.cursor) {\n        self.cursor.remove();\n      }\n\n      if (self.cursorh) {\n        self.cursorh.remove();\n      }\n\n      if (self.rail) {\n        self.rail.remove();\n      }\n\n      if (self.railh) {\n        self.railh.remove();\n      }\n\n      if (self.zoom) {\n        self.zoom.remove();\n      }\n\n      for (var a = 0; a < self.saved.css.length; a++) {\n        var d = self.saved.css[a];\n        d[0].css(d[1], d[2] === undefined ? '' : d[2]);\n      }\n\n      self.saved = false;\n      self.me.data('__nicescroll', ''); //erase all traces\n      // memory leak fixed by GianlucaGuarini - thanks a lot!\n      // remove the current nicescroll from the $.nicescroll array & normalize array\n\n      var lst = $.nicescroll;\n      lst.each(function (i) {\n        if (!this) return;\n\n        if (this.id === self.id) {\n          delete lst[i];\n\n          for (var b = ++i; b < lst.length; b++, i++) lst[i] = lst[b];\n\n          lst.length--;\n          if (lst.length) delete lst[lst.length];\n        }\n      });\n\n      for (var i in self) {\n        self[i] = null;\n        delete self[i];\n      }\n\n      self = null;\n    };\n\n    this.scrollstart = function (fn) {\n      this.onscrollstart = fn;\n      return self;\n    };\n\n    this.scrollend = function (fn) {\n      this.onscrollend = fn;\n      return self;\n    };\n\n    this.scrollcancel = function (fn) {\n      this.onscrollcancel = fn;\n      return self;\n    };\n\n    this.zoomin = function (fn) {\n      this.onzoomin = fn;\n      return self;\n    };\n\n    this.zoomout = function (fn) {\n      this.onzoomout = fn;\n      return self;\n    };\n\n    this.isScrollable = function (e) {\n      var dom = e.target ? e.target : e;\n      if (dom.nodeName == 'OPTION') return true;\n\n      while (dom && dom.nodeType == 1 && dom !== this.me[0] && !/^BODY|HTML/.test(dom.nodeName)) {\n        var dd = $(dom);\n        var ov = dd.css('overflowY') || dd.css('overflowX') || dd.css('overflow') || '';\n        if (/scroll|auto/.test(ov)) return dom.clientHeight != dom.scrollHeight;\n        dom = dom.parentNode ? dom.parentNode : false;\n      }\n\n      return false;\n    };\n\n    this.getViewport = function (me) {\n      var dom = me && me.parentNode ? me.parentNode : false;\n\n      while (dom && dom.nodeType == 1 && !/^BODY|HTML/.test(dom.nodeName)) {\n        var dd = $(dom);\n        if (/fixed|absolute/.test(dd.css(\"position\"))) return dd;\n        var ov = dd.css('overflowY') || dd.css('overflowX') || dd.css('overflow') || '';\n        if (/scroll|auto/.test(ov) && dom.clientHeight != dom.scrollHeight) return dd;\n        if (dd.getNiceScroll().length > 0) return dd;\n        dom = dom.parentNode ? dom.parentNode : false;\n      }\n\n      return false;\n    };\n\n    this.triggerScrollStart = function (cx, cy, rx, ry, ms) {\n      if (self.onscrollstart) {\n        var info = {\n          type: \"scrollstart\",\n          current: {\n            x: cx,\n            y: cy\n          },\n          request: {\n            x: rx,\n            y: ry\n          },\n          end: {\n            x: self.newscrollx,\n            y: self.newscrolly\n          },\n          speed: ms\n        };\n        self.onscrollstart.call(self, info);\n      }\n    };\n\n    this.triggerScrollEnd = function () {\n      if (self.onscrollend) {\n        var px = self.getScrollLeft();\n        var py = self.getScrollTop();\n        var info = {\n          type: \"scrollend\",\n          current: {\n            x: px,\n            y: py\n          },\n          end: {\n            x: px,\n            y: py\n          }\n        };\n        self.onscrollend.call(self, info);\n      }\n    };\n\n    var scrolldiry = 0,\n        scrolldirx = 0,\n        scrolltmr = 0,\n        scrollspd = 1;\n\n    function doScrollRelative(px, py, chkscroll, iswheel) {\n      if (!self.scrollrunning) {\n        self.newscrolly = self.getScrollTop();\n        self.newscrollx = self.getScrollLeft();\n        scrolltmr = now();\n      }\n\n      var gap = now() - scrolltmr;\n      scrolltmr = now();\n\n      if (gap > 350) {\n        scrollspd = 1;\n      } else {\n        scrollspd += (2 - scrollspd) / 10;\n      }\n\n      px = px * scrollspd | 0;\n      py = py * scrollspd | 0;\n\n      if (px) {\n        if (iswheel) {\n          // mouse-only\n          if (px < 0) {\n            // fix apple magic mouse swipe back/forward\n            if (self.getScrollLeft() >= self.page.maxw) return true;\n          } else {\n            if (self.getScrollLeft() <= 0) return true;\n          }\n        }\n\n        var dx = px > 0 ? 1 : -1;\n\n        if (scrolldirx !== dx) {\n          if (self.scrollmom) self.scrollmom.stop();\n          self.newscrollx = self.getScrollLeft();\n          scrolldirx = dx;\n        }\n\n        self.lastdeltax -= px;\n      }\n\n      if (py) {\n        var chk = function () {\n          var top = self.getScrollTop();\n\n          if (py < 0) {\n            if (top >= self.page.maxh) return true;\n          } else {\n            if (top <= 0) return true;\n          }\n        }();\n\n        if (chk) {\n          if (opt.nativeparentscrolling && chkscroll && !self.ispage && !self.zoomactive) return true;\n          var ny = self.view.h >> 1;\n\n          if (self.newscrolly < -ny) {\n            self.newscrolly = -ny;\n            py = -1;\n          } else if (self.newscrolly > self.page.maxh + ny) {\n            self.newscrolly = self.page.maxh + ny;\n            py = 1;\n          } else py = 0;\n        }\n\n        var dy = py > 0 ? 1 : -1;\n\n        if (scrolldiry !== dy) {\n          if (self.scrollmom) self.scrollmom.stop();\n          self.newscrolly = self.getScrollTop();\n          scrolldiry = dy;\n        }\n\n        self.lastdeltay -= py;\n      }\n\n      if (py || px) {\n        self.synched(\"relativexy\", function () {\n          var dty = self.lastdeltay + self.newscrolly;\n          self.lastdeltay = 0;\n          var dtx = self.lastdeltax + self.newscrollx;\n          self.lastdeltax = 0;\n          if (!self.rail.drag) self.doScrollPos(dtx, dty);\n        });\n      }\n    }\n\n    var hasparentscrollingphase = false;\n\n    function execScrollWheel(e, hr, chkscroll) {\n      var px, py;\n      if (!chkscroll && hasparentscrollingphase) return true;\n\n      if (e.deltaMode === 0) {\n        // PIXEL\n        px = -(e.deltaX * (opt.mousescrollstep / (18 * 3))) | 0;\n        py = -(e.deltaY * (opt.mousescrollstep / (18 * 3))) | 0;\n      } else if (e.deltaMode === 1) {\n        // LINE\n        px = -(e.deltaX * opt.mousescrollstep * 50 / 80) | 0;\n        py = -(e.deltaY * opt.mousescrollstep * 50 / 80) | 0;\n      }\n\n      if (hr && opt.oneaxismousemode && px === 0 && py) {\n        // classic vertical-only mousewheel + browser with x/y support \n        px = py;\n        py = 0;\n\n        if (chkscroll) {\n          var hrend = px < 0 ? self.getScrollLeft() >= self.page.maxw : self.getScrollLeft() <= 0;\n\n          if (hrend) {\n            // preserve vertical scrolling\n            py = px;\n            px = 0;\n          }\n        }\n      } // invert horizontal direction for rtl mode\n\n\n      if (self.isrtlmode) px = -px;\n      var chk = doScrollRelative(px, py, chkscroll, true);\n\n      if (chk) {\n        if (chkscroll) hasparentscrollingphase = true;\n      } else {\n        hasparentscrollingphase = false;\n        e.stopImmediatePropagation();\n        return e.preventDefault();\n      }\n    }\n\n    this.onmousewheel = function (e) {\n      if (self.wheelprevented || self.locked) return false;\n\n      if (self.railslocked) {\n        self.debounced(\"checkunlock\", self.resize, 250);\n        return false;\n      }\n\n      if (self.rail.drag) return self.cancelEvent(e);\n      if (opt.oneaxismousemode === \"auto\" && e.deltaX !== 0) opt.oneaxismousemode = false; // check two-axis mouse support (not very elegant)\n\n      if (opt.oneaxismousemode && e.deltaX === 0) {\n        if (!self.rail.scrollable) {\n          if (self.railh && self.railh.scrollable) {\n            return self.onmousewheelhr(e);\n          } else {\n            return true;\n          }\n        }\n      }\n\n      var nw = now();\n      var chk = false;\n\n      if (opt.preservenativescrolling && self.checkarea + 600 < nw) {\n        self.nativescrollingarea = self.isScrollable(e);\n        chk = true;\n      }\n\n      self.checkarea = nw;\n      if (self.nativescrollingarea) return true; // this isn't my business\n\n      var ret = execScrollWheel(e, false, chk);\n      if (ret) self.checkarea = 0;\n      return ret;\n    };\n\n    this.onmousewheelhr = function (e) {\n      if (self.wheelprevented) return;\n      if (self.railslocked || !self.railh.scrollable) return true;\n      if (self.rail.drag) return self.cancelEvent(e);\n      var nw = now();\n      var chk = false;\n\n      if (opt.preservenativescrolling && self.checkarea + 600 < nw) {\n        self.nativescrollingarea = self.isScrollable(e);\n        chk = true;\n      }\n\n      self.checkarea = nw;\n      if (self.nativescrollingarea) return true; // this is not my business\n\n      if (self.railslocked) return self.cancelEvent(e);\n      return execScrollWheel(e, true, chk);\n    };\n\n    this.stop = function () {\n      self.cancelScroll();\n      if (self.scrollmon) self.scrollmon.stop();\n      self.cursorfreezed = false;\n      self.scroll.y = Math.round(self.getScrollTop() * (1 / self.scrollratio.y));\n      self.noticeCursor();\n      return self;\n    };\n\n    this.getTransitionSpeed = function (dif) {\n      return 80 + dif / 72 * opt.scrollspeed | 0;\n    };\n\n    if (!opt.smoothscroll) {\n      this.doScrollLeft = function (x, spd) {\n        //direct\n        var y = self.getScrollTop();\n        self.doScrollPos(x, y, spd);\n      };\n\n      this.doScrollTop = function (y, spd) {\n        //direct\n        var x = self.getScrollLeft();\n        self.doScrollPos(x, y, spd);\n      };\n\n      this.doScrollPos = function (x, y, spd) {\n        //direct\n        var nx = x > self.page.maxw ? self.page.maxw : x;\n        if (nx < 0) nx = 0;\n        var ny = y > self.page.maxh ? self.page.maxh : y;\n        if (ny < 0) ny = 0;\n        self.synched('scroll', function () {\n          self.setScrollTop(ny);\n          self.setScrollLeft(nx);\n        });\n      };\n\n      this.cancelScroll = function () {}; // direct\n\n    } else if (self.ishwscroll && cap.hastransition && opt.usetransition && !!opt.smoothscroll) {\n      var lasttransitionstyle = '';\n\n      this.resetTransition = function () {\n        lasttransitionstyle = '';\n        self.doc.css(cap.prefixstyle + 'transition-duration', '0ms');\n      };\n\n      this.prepareTransition = function (dif, istime) {\n        var ex = istime ? dif : self.getTransitionSpeed(dif);\n        var trans = ex + 'ms';\n\n        if (lasttransitionstyle !== trans) {\n          lasttransitionstyle = trans;\n          self.doc.css(cap.prefixstyle + 'transition-duration', trans);\n        }\n\n        return ex;\n      };\n\n      this.doScrollLeft = function (x, spd) {\n        //trans\n        var y = self.scrollrunning ? self.newscrolly : self.getScrollTop();\n        self.doScrollPos(x, y, spd);\n      };\n\n      this.doScrollTop = function (y, spd) {\n        //trans\n        var x = self.scrollrunning ? self.newscrollx : self.getScrollLeft();\n        self.doScrollPos(x, y, spd);\n      };\n\n      this.cursorupdate = {\n        running: false,\n        start: function () {\n          var m = this;\n          if (m.running) return;\n          m.running = true;\n\n          var loop = function () {\n            if (m.running) setAnimationFrame(loop);\n            self.showCursor(self.getScrollTop(), self.getScrollLeft());\n            self.notifyScrollEvent(self.win[0]);\n          };\n\n          setAnimationFrame(loop);\n        },\n        stop: function () {\n          this.running = false;\n        }\n      };\n\n      this.doScrollPos = function (x, y, spd) {\n        //trans\n        var py = self.getScrollTop();\n        var px = self.getScrollLeft();\n        if ((self.newscrolly - py) * (y - py) < 0 || (self.newscrollx - px) * (x - px) < 0) self.cancelScroll(); //inverted movement detection      \n\n        if (!opt.bouncescroll) {\n          if (y < 0) y = 0;else if (y > self.page.maxh) y = self.page.maxh;\n          if (x < 0) x = 0;else if (x > self.page.maxw) x = self.page.maxw;\n        } else {\n          if (y < 0) y = y / 2 | 0;else if (y > self.page.maxh) y = self.page.maxh + (y - self.page.maxh) / 2 | 0;\n          if (x < 0) x = x / 2 | 0;else if (x > self.page.maxw) x = self.page.maxw + (x - self.page.maxw) / 2 | 0;\n        }\n\n        if (self.scrollrunning && x == self.newscrollx && y == self.newscrolly) return false;\n        self.newscrolly = y;\n        self.newscrollx = x;\n        var top = self.getScrollTop();\n        var lft = self.getScrollLeft();\n        var dst = {};\n        dst.x = x - lft;\n        dst.y = y - top;\n        var dd = Math.sqrt(dst.x * dst.x + dst.y * dst.y) | 0;\n        var ms = self.prepareTransition(dd);\n\n        if (!self.scrollrunning) {\n          self.scrollrunning = true;\n          self.triggerScrollStart(lft, top, x, y, ms);\n          self.cursorupdate.start();\n        }\n\n        self.scrollendtrapped = true;\n\n        if (!cap.transitionend) {\n          if (self.scrollendtrapped) clearTimeout(self.scrollendtrapped);\n          self.scrollendtrapped = setTimeout(self.onScrollTransitionEnd, ms); // simulate transitionend event\n        }\n\n        self.setScrollTop(self.newscrolly);\n        self.setScrollLeft(self.newscrollx);\n      };\n\n      this.cancelScroll = function () {\n        if (!self.scrollendtrapped) return true;\n        var py = self.getScrollTop();\n        var px = self.getScrollLeft();\n        self.scrollrunning = false;\n        if (!cap.transitionend) clearTimeout(cap.transitionend);\n        self.scrollendtrapped = false;\n        self.resetTransition();\n        self.setScrollTop(py); // fire event onscroll\n\n        if (self.railh) self.setScrollLeft(px);\n        if (self.timerscroll && self.timerscroll.tm) clearInterval(self.timerscroll.tm);\n        self.timerscroll = false;\n        self.cursorfreezed = false;\n        self.cursorupdate.stop();\n        self.showCursor(py, px);\n        return self;\n      };\n\n      this.onScrollTransitionEnd = function () {\n        if (!self.scrollendtrapped) return;\n        var py = self.getScrollTop();\n        var px = self.getScrollLeft();\n        if (py < 0) py = 0;else if (py > self.page.maxh) py = self.page.maxh;\n        if (px < 0) px = 0;else if (px > self.page.maxw) px = self.page.maxw;\n        if (py != self.newscrolly || px != self.newscrollx) return self.doScrollPos(px, py, opt.snapbackspeed);\n        if (self.scrollrunning) self.triggerScrollEnd();\n        self.scrollrunning = false;\n        self.scrollendtrapped = false;\n        self.resetTransition();\n        self.timerscroll = false;\n        self.setScrollTop(py); // fire event onscroll        \n\n        if (self.railh) self.setScrollLeft(px); // fire event onscroll left\n\n        self.cursorupdate.stop();\n        self.noticeCursor(false, py, px);\n        self.cursorfreezed = false;\n      };\n    } else {\n      this.doScrollLeft = function (x, spd) {\n        //no-trans\n        var y = self.scrollrunning ? self.newscrolly : self.getScrollTop();\n        self.doScrollPos(x, y, spd);\n      };\n\n      this.doScrollTop = function (y, spd) {\n        //no-trans\n        var x = self.scrollrunning ? self.newscrollx : self.getScrollLeft();\n        self.doScrollPos(x, y, spd);\n      };\n\n      this.doScrollPos = function (x, y, spd) {\n        //no-trans\n        var py = self.getScrollTop();\n        var px = self.getScrollLeft();\n        if ((self.newscrolly - py) * (y - py) < 0 || (self.newscrollx - px) * (x - px) < 0) self.cancelScroll(); //inverted movement detection\n\n        var clipped = false;\n\n        if (!self.bouncescroll || !self.rail.visibility) {\n          if (y < 0) {\n            y = 0;\n            clipped = true;\n          } else if (y > self.page.maxh) {\n            y = self.page.maxh;\n            clipped = true;\n          }\n        }\n\n        if (!self.bouncescroll || !self.railh.visibility) {\n          if (x < 0) {\n            x = 0;\n            clipped = true;\n          } else if (x > self.page.maxw) {\n            x = self.page.maxw;\n            clipped = true;\n          }\n        }\n\n        if (self.scrollrunning && self.newscrolly === y && self.newscrollx === x) return true;\n        self.newscrolly = y;\n        self.newscrollx = x;\n        self.dst = {};\n        self.dst.x = x - px;\n        self.dst.y = y - py;\n        self.dst.px = px;\n        self.dst.py = py;\n        var dd = Math.sqrt(self.dst.x * self.dst.x + self.dst.y * self.dst.y) | 0;\n        var ms = self.getTransitionSpeed(dd);\n        self.bzscroll = {};\n        var p3 = clipped ? 1 : 0.58;\n        self.bzscroll.x = new BezierClass(px, self.newscrollx, ms, 0, 0, p3, 1);\n        self.bzscroll.y = new BezierClass(py, self.newscrolly, ms, 0, 0, p3, 1);\n        var loopid = now();\n\n        var loop = function () {\n          if (!self.scrollrunning) return;\n          var x = self.bzscroll.y.getPos();\n          self.setScrollLeft(self.bzscroll.x.getNow());\n          self.setScrollTop(self.bzscroll.y.getNow());\n\n          if (x <= 1) {\n            self.timer = setAnimationFrame(loop);\n          } else {\n            self.scrollrunning = false;\n            self.timer = 0;\n            self.triggerScrollEnd();\n          }\n        };\n\n        if (!self.scrollrunning) {\n          self.triggerScrollStart(px, py, x, y, ms);\n          self.scrollrunning = true;\n          self.timer = setAnimationFrame(loop);\n        }\n      };\n\n      this.cancelScroll = function () {\n        if (self.timer) clearAnimationFrame(self.timer);\n        self.timer = 0;\n        self.bzscroll = false;\n        self.scrollrunning = false;\n        return self;\n      };\n    }\n\n    this.doScrollBy = function (stp, relative) {\n      doScrollRelative(0, stp);\n    };\n\n    this.doScrollLeftBy = function (stp, relative) {\n      doScrollRelative(stp, 0);\n    };\n\n    this.doScrollTo = function (pos, relative) {\n      var ny = relative ? Math.round(pos * self.scrollratio.y) : pos;\n      if (ny < 0) ny = 0;else if (ny > self.page.maxh) ny = self.page.maxh;\n      self.cursorfreezed = false;\n      self.doScrollTop(pos);\n    };\n\n    this.checkContentSize = function () {\n      var pg = self.getContentSize();\n      if (pg.h != self.page.h || pg.w != self.page.w) self.resize(false, pg);\n    };\n\n    self.onscroll = function (e) {\n      if (self.rail.drag) return;\n\n      if (!self.cursorfreezed) {\n        self.synched('scroll', function () {\n          self.scroll.y = Math.round(self.getScrollTop() / self.scrollratio.y);\n          if (self.railh) self.scroll.x = Math.round(self.getScrollLeft() / self.scrollratio.x);\n          self.noticeCursor();\n        });\n      }\n    };\n\n    self.bind(self.docscroll, \"scroll\", self.onscroll);\n\n    this.doZoomIn = function (e) {\n      if (self.zoomactive) return;\n      self.zoomactive = true;\n      self.zoomrestore = {\n        style: {}\n      };\n      var lst = ['position', 'top', 'left', 'zIndex', 'backgroundColor', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight'];\n      var win = self.win[0].style;\n\n      for (var a in lst) {\n        var pp = lst[a];\n        self.zoomrestore.style[pp] = win[pp] !== undefined ? win[pp] : '';\n      }\n\n      self.zoomrestore.style.width = self.win.css('width');\n      self.zoomrestore.style.height = self.win.css('height');\n      self.zoomrestore.padding = {\n        w: self.win.outerWidth() - self.win.width(),\n        h: self.win.outerHeight() - self.win.height()\n      };\n\n      if (cap.isios4) {\n        self.zoomrestore.scrollTop = $window.scrollTop();\n        $window.scrollTop(0);\n      }\n\n      self.win.css({\n        position: cap.isios4 ? \"absolute\" : \"fixed\",\n        top: 0,\n        left: 0,\n        zIndex: globalmaxzindex + 100,\n        margin: 0\n      });\n      var bkg = self.win.css(\"backgroundColor\");\n      if (\"\" === bkg || /transparent|rgba\\(0, 0, 0, 0\\)|rgba\\(0,0,0,0\\)/.test(bkg)) self.win.css(\"backgroundColor\", \"#fff\");\n      self.rail.css({\n        zIndex: globalmaxzindex + 101\n      });\n      self.zoom.css({\n        zIndex: globalmaxzindex + 102\n      });\n      self.zoom.css('backgroundPosition', '0 -18px');\n      self.resizeZoom();\n      if (self.onzoomin) self.onzoomin.call(self);\n      return self.cancelEvent(e);\n    };\n\n    this.doZoomOut = function (e) {\n      if (!self.zoomactive) return;\n      self.zoomactive = false;\n      self.win.css(\"margin\", \"\");\n      self.win.css(self.zoomrestore.style);\n\n      if (cap.isios4) {\n        $window.scrollTop(self.zoomrestore.scrollTop);\n      }\n\n      self.rail.css({\n        \"z-index\": self.zindex\n      });\n      self.zoom.css({\n        \"z-index\": self.zindex\n      });\n      self.zoomrestore = false;\n      self.zoom.css('backgroundPosition', '0 0');\n      self.onResize();\n      if (self.onzoomout) self.onzoomout.call(self);\n      return self.cancelEvent(e);\n    };\n\n    this.doZoom = function (e) {\n      return self.zoomactive ? self.doZoomOut(e) : self.doZoomIn(e);\n    };\n\n    this.resizeZoom = function () {\n      if (!self.zoomactive) return;\n      var py = self.getScrollTop(); //preserve scrolling position\n\n      self.win.css({\n        width: $window.width() - self.zoomrestore.padding.w + \"px\",\n        height: $window.height() - self.zoomrestore.padding.h + \"px\"\n      });\n      self.onResize();\n      self.setScrollTop(Math.min(self.page.maxh, py));\n    };\n\n    this.init();\n    $.nicescroll.push(this);\n  }; // Inspired by the work of Kin Blas\n  // http://webpro.host.adobe.com/people/jblas/momentum/includes/jquery.momentum.0.7.js  \n\n\n  var ScrollMomentumClass2D = function (nc) {\n    var self = this;\n    this.nc = nc;\n    this.lastx = 0;\n    this.lasty = 0;\n    this.speedx = 0;\n    this.speedy = 0;\n    this.lasttime = 0;\n    this.steptime = 0;\n    this.snapx = false;\n    this.snapy = false;\n    this.demulx = 0;\n    this.demuly = 0;\n    this.lastscrollx = -1;\n    this.lastscrolly = -1;\n    this.chkx = 0;\n    this.chky = 0;\n    this.timer = 0;\n\n    this.reset = function (px, py) {\n      self.stop();\n      self.steptime = 0;\n      self.lasttime = now();\n      self.speedx = 0;\n      self.speedy = 0;\n      self.lastx = px;\n      self.lasty = py;\n      self.lastscrollx = -1;\n      self.lastscrolly = -1;\n    };\n\n    this.update = function (px, py) {\n      var tm = now();\n      self.steptime = tm - self.lasttime;\n      self.lasttime = tm;\n      var dy = py - self.lasty;\n      var dx = px - self.lastx;\n      var sy = self.nc.getScrollTop();\n      var sx = self.nc.getScrollLeft();\n      var newy = sy + dy;\n      var newx = sx + dx;\n      self.snapx = newx < 0 || newx > self.nc.page.maxw;\n      self.snapy = newy < 0 || newy > self.nc.page.maxh;\n      self.speedx = dx;\n      self.speedy = dy;\n      self.lastx = px;\n      self.lasty = py;\n    };\n\n    this.stop = function () {\n      self.nc.unsynched(\"domomentum2d\");\n      if (self.timer) clearTimeout(self.timer);\n      self.timer = 0;\n      self.lastscrollx = -1;\n      self.lastscrolly = -1;\n    };\n\n    this.doSnapy = function (nx, ny) {\n      var snap = false;\n\n      if (ny < 0) {\n        ny = 0;\n        snap = true;\n      } else if (ny > self.nc.page.maxh) {\n        ny = self.nc.page.maxh;\n        snap = true;\n      }\n\n      if (nx < 0) {\n        nx = 0;\n        snap = true;\n      } else if (nx > self.nc.page.maxw) {\n        nx = self.nc.page.maxw;\n        snap = true;\n      }\n\n      snap ? self.nc.doScrollPos(nx, ny, self.nc.opt.snapbackspeed) : self.nc.triggerScrollEnd();\n    };\n\n    this.doMomentum = function (gp) {\n      var t = now();\n      var l = gp ? t + gp : self.lasttime;\n      var sl = self.nc.getScrollLeft();\n      var st = self.nc.getScrollTop();\n      var pageh = self.nc.page.maxh;\n      var pagew = self.nc.page.maxw;\n      self.speedx = pagew > 0 ? Math.min(60, self.speedx) : 0;\n      self.speedy = pageh > 0 ? Math.min(60, self.speedy) : 0;\n      var chk = l && t - l <= 60;\n      if (st < 0 || st > pageh || sl < 0 || sl > pagew) chk = false;\n      var sy = self.speedy && chk ? self.speedy : false;\n      var sx = self.speedx && chk ? self.speedx : false;\n\n      if (sy || sx) {\n        var tm = Math.max(16, self.steptime); //timeout granularity\n\n        if (tm > 50) {\n          // do smooth\n          var xm = tm / 50;\n          self.speedx *= xm;\n          self.speedy *= xm;\n          tm = 50;\n        }\n\n        self.demulxy = 0;\n        self.lastscrollx = self.nc.getScrollLeft();\n        self.chkx = self.lastscrollx;\n        self.lastscrolly = self.nc.getScrollTop();\n        self.chky = self.lastscrolly;\n        var nx = self.lastscrollx;\n        var ny = self.lastscrolly;\n\n        var onscroll = function () {\n          var df = now() - t > 600 ? 0.04 : 0.02;\n\n          if (self.speedx) {\n            nx = Math.floor(self.lastscrollx - self.speedx * (1 - self.demulxy));\n            self.lastscrollx = nx;\n            if (nx < 0 || nx > pagew) df = 0.10;\n          }\n\n          if (self.speedy) {\n            ny = Math.floor(self.lastscrolly - self.speedy * (1 - self.demulxy));\n            self.lastscrolly = ny;\n            if (ny < 0 || ny > pageh) df = 0.10;\n          }\n\n          self.demulxy = Math.min(1, self.demulxy + df);\n          self.nc.synched(\"domomentum2d\", function () {\n            if (self.speedx) {\n              var scx = self.nc.getScrollLeft(); //              if (scx != self.chkx) self.stop();\n\n              self.chkx = nx;\n              self.nc.setScrollLeft(nx);\n            }\n\n            if (self.speedy) {\n              var scy = self.nc.getScrollTop(); //              if (scy != self.chky) self.stop();\n\n              self.chky = ny;\n              self.nc.setScrollTop(ny);\n            }\n\n            if (!self.timer) {\n              self.nc.hideCursor();\n              self.doSnapy(nx, ny);\n            }\n          });\n\n          if (self.demulxy < 1) {\n            self.timer = setTimeout(onscroll, tm);\n          } else {\n            self.stop();\n            self.nc.hideCursor();\n            self.doSnapy(nx, ny);\n          }\n        };\n\n        onscroll();\n      } else {\n        self.doSnapy(self.nc.getScrollLeft(), self.nc.getScrollTop());\n      }\n    };\n  }; // override jQuery scrollTop\n\n\n  var _scrollTop = jQuery.fn.scrollTop; // preserve original function\n\n  jQuery.cssHooks.pageYOffset = {\n    get: function (elem, computed, extra) {\n      var nice = $.data(elem, '__nicescroll') || false;\n      return nice && nice.ishwscroll ? nice.getScrollTop() : _scrollTop.call(elem);\n    },\n    set: function (elem, value) {\n      var nice = $.data(elem, '__nicescroll') || false;\n      nice && nice.ishwscroll ? nice.setScrollTop(parseInt(value)) : _scrollTop.call(elem, value);\n      return this;\n    }\n  };\n\n  jQuery.fn.scrollTop = function (value) {\n    if (value === undefined) {\n      var nice = this[0] ? $.data(this[0], '__nicescroll') || false : false;\n      return nice && nice.ishwscroll ? nice.getScrollTop() : _scrollTop.call(this);\n    } else {\n      return this.each(function () {\n        var nice = $.data(this, '__nicescroll') || false;\n        nice && nice.ishwscroll ? nice.setScrollTop(parseInt(value)) : _scrollTop.call($(this), value);\n      });\n    }\n  }; // override jQuery scrollLeft\n\n\n  var _scrollLeft = jQuery.fn.scrollLeft; // preserve original function\n\n  $.cssHooks.pageXOffset = {\n    get: function (elem, computed, extra) {\n      var nice = $.data(elem, '__nicescroll') || false;\n      return nice && nice.ishwscroll ? nice.getScrollLeft() : _scrollLeft.call(elem);\n    },\n    set: function (elem, value) {\n      var nice = $.data(elem, '__nicescroll') || false;\n      nice && nice.ishwscroll ? nice.setScrollLeft(parseInt(value)) : _scrollLeft.call(elem, value);\n      return this;\n    }\n  };\n\n  jQuery.fn.scrollLeft = function (value) {\n    if (value === undefined) {\n      var nice = this[0] ? $.data(this[0], '__nicescroll') || false : false;\n      return nice && nice.ishwscroll ? nice.getScrollLeft() : _scrollLeft.call(this);\n    } else {\n      return this.each(function () {\n        var nice = $.data(this, '__nicescroll') || false;\n        nice && nice.ishwscroll ? nice.setScrollLeft(parseInt(value)) : _scrollLeft.call($(this), value);\n      });\n    }\n  };\n\n  var NiceScrollArray = function (doms) {\n    var self = this;\n    this.length = 0;\n    this.name = \"nicescrollarray\";\n\n    this.each = function (fn) {\n      $.each(self, fn);\n      return self;\n    };\n\n    this.push = function (nice) {\n      self[self.length] = nice;\n      self.length++;\n    };\n\n    this.eq = function (idx) {\n      return self[idx];\n    };\n\n    if (doms) {\n      for (var a = 0; a < doms.length; a++) {\n        var nice = $.data(doms[a], '__nicescroll') || false;\n\n        if (nice) {\n          this[this.length] = nice;\n          this.length++;\n        }\n      }\n    }\n\n    return this;\n  };\n\n  function mplex(el, lst, fn) {\n    for (var a = 0, l = lst.length; a < l; a++) fn(el, lst[a]);\n  }\n\n  mplex(NiceScrollArray.prototype, ['show', 'hide', 'toggle', 'onResize', 'resize', 'remove', 'stop', 'doScrollPos'], function (e, n) {\n    e[n] = function () {\n      var args = arguments;\n      return this.each(function () {\n        this[n].apply(this, args);\n      });\n    };\n  });\n\n  jQuery.fn.getNiceScroll = function (index) {\n    if (index === undefined) {\n      return new NiceScrollArray(this);\n    } else {\n      return this[index] && $.data(this[index], '__nicescroll') || false;\n    }\n  };\n\n  var pseudos = jQuery.expr.pseudos || jQuery.expr[':']; // jQuery 3 migration\n\n  pseudos.nicescroll = function (a) {\n    return $.data(a, '__nicescroll') !== undefined;\n  };\n\n  $.fn.niceScroll = function (wrapper, _opt) {\n    if (_opt === undefined && typeof wrapper == \"object\" && !(\"jquery\" in wrapper)) {\n      _opt = wrapper;\n      wrapper = false;\n    }\n\n    var ret = new NiceScrollArray();\n    this.each(function () {\n      var $this = $(this);\n      var opt = $.extend({}, _opt); // cloning\n\n      if (wrapper || false) {\n        var wrp = $(wrapper);\n        opt.doc = wrp.length > 1 ? $(wrapper, $this) : wrp;\n        opt.win = $this;\n      }\n\n      var docundef = !(\"doc\" in opt);\n      if (!docundef && !(\"win\" in opt)) opt.win = $this;\n      var nice = $this.data('__nicescroll') || false;\n\n      if (!nice) {\n        opt.doc = opt.doc || $this;\n        nice = new NiceScrollClass(opt, $this);\n        $this.data('__nicescroll', nice);\n      }\n\n      ret.push(nice);\n    });\n    return ret.length === 1 ? ret[0] : ret;\n  };\n\n  _win.NiceScroll = {\n    getjQuery: function () {\n      return jQuery;\n    }\n  };\n\n  if (!$.nicescroll) {\n    $.nicescroll = new NiceScrollArray();\n    $.nicescroll.options = _globaloptions;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}