{"ast":null,"code":"/*!\n* inputmask.date.extensions.js\n* https://github.com/RobinHerbots/Inputmask\n* Copyright (c) 2010 - 2019 Robin Herbots\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\n* Version: 4.0.9\n*/\n(function (factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"./inputmask\"], factory);\n  } else if (typeof exports === \"object\") {\n    module.exports = factory(require(\"./inputmask\"));\n  } else {\n    factory(window.Inputmask);\n  }\n})(function (Inputmask) {\n  var $ = Inputmask.dependencyLib;\n  var formatCode = {\n    d: [\"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate],\n    dd: [\"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function () {\n      return pad(Date.prototype.getDate.call(this), 2);\n    }],\n    ddd: [\"\"],\n    dddd: [\"\"],\n    m: [\"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\n      return Date.prototype.getMonth.call(this) + 1;\n    }],\n    mm: [\"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\n      return pad(Date.prototype.getMonth.call(this) + 1, 2);\n    }],\n    mmm: [\"\"],\n    mmmm: [\"\"],\n    yy: [\"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function () {\n      return pad(Date.prototype.getFullYear.call(this), 2);\n    }],\n    yyyy: [\"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function () {\n      return pad(Date.prototype.getFullYear.call(this), 4);\n    }],\n    h: [\"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours],\n    hh: [\"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function () {\n      return pad(Date.prototype.getHours.call(this), 2);\n    }],\n    hhh: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours],\n    H: [\"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours],\n    HH: [\"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function () {\n      return pad(Date.prototype.getHours.call(this), 2);\n    }],\n    HHH: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours],\n    M: [\"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes],\n    MM: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function () {\n      return pad(Date.prototype.getMinutes.call(this), 2);\n    }],\n    ss: [\"[0-5][0-9]\", Date.prototype.setSeconds, \"seconds\", function () {\n      return pad(Date.prototype.getSeconds.call(this), 2);\n    }],\n    l: [\"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\n      return pad(Date.prototype.getMilliseconds.call(this), 3);\n    }],\n    L: [\"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\n      return pad(Date.prototype.getMilliseconds.call(this), 2);\n    }],\n    t: [\"[ap]\"],\n    tt: [\"[ap]m\"],\n    T: [\"[AP]\"],\n    TT: [\"[AP]M\"],\n    Z: [\"\"],\n    o: [\"\"],\n    S: [\"\"]\n  },\n      formatAlias = {\n    isoDate: \"yyyy-mm-dd\",\n    isoTime: \"HH:MM:ss\",\n    isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\n    isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\"\n  };\n\n  function getTokenizer(opts) {\n    if (!opts.tokenizer) {\n      var tokens = [];\n\n      for (var ndx in formatCode) {\n        if (tokens.indexOf(ndx[0]) === -1) tokens.push(ndx[0]);\n      }\n\n      opts.tokenizer = \"(\" + tokens.join(\"+|\") + \")+?|.\";\n      opts.tokenizer = new RegExp(opts.tokenizer, \"g\");\n    }\n\n    return opts.tokenizer;\n  }\n\n  function isValidDate(dateParts, currentResult) {\n    return !isFinite(dateParts.rawday) || dateParts.day == \"29\" && !isFinite(dateParts.rawyear) || new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day ? currentResult : false;\n  }\n\n  function isDateInRange(dateParts, opts) {\n    var result = true;\n\n    if (opts.min) {\n      if (dateParts[\"rawyear\"]) {\n        var rawYear = dateParts[\"rawyear\"].replace(/[^0-9]/g, \"\"),\n            minYear = opts.min.year.substr(0, rawYear.length);\n        result = minYear <= rawYear;\n      }\n\n      if (dateParts[\"year\"] === dateParts[\"rawyear\"]) {\n        if (opts.min.date.getTime() === opts.min.date.getTime()) {\n          result = opts.min.date.getTime() <= dateParts.date.getTime();\n        }\n      }\n    }\n\n    if (result && opts.max && opts.max.date.getTime() === opts.max.date.getTime()) {\n      result = opts.max.date.getTime() >= dateParts.date.getTime();\n    }\n\n    return result;\n  }\n\n  function parse(format, dateObjValue, opts, raw) {\n    var mask = \"\",\n        match;\n\n    while (match = getTokenizer(opts).exec(format)) {\n      if (dateObjValue === undefined) {\n        if (formatCode[match[0]]) {\n          mask += \"(\" + formatCode[match[0]][0] + \")\";\n        } else {\n          switch (match[0]) {\n            case \"[\":\n              mask += \"(\";\n              break;\n\n            case \"]\":\n              mask += \")?\";\n              break;\n\n            default:\n              mask += Inputmask.escapeRegex(match[0]);\n          }\n        }\n      } else {\n        if (formatCode[match[0]]) {\n          if (raw !== true && formatCode[match[0]][3]) {\n            var getFn = formatCode[match[0]][3];\n            mask += getFn.call(dateObjValue.date);\n          } else if (formatCode[match[0]][2]) mask += dateObjValue[\"raw\" + formatCode[match[0]][2]];else mask += match[0];\n        } else mask += match[0];\n      }\n    }\n\n    return mask;\n  }\n\n  function pad(val, len) {\n    val = String(val);\n    len = len || 2;\n\n    while (val.length < len) val = \"0\" + val;\n\n    return val;\n  }\n\n  function analyseMask(maskString, format, opts) {\n    var dateObj = {\n      date: new Date(1, 0, 1)\n    },\n        targetProp,\n        mask = maskString,\n        match,\n        dateOperation,\n        targetValidator;\n\n    function extendProperty(value) {\n      var correctedValue = value.replace(/[^0-9]/g, \"0\");\n\n      if (correctedValue != value) {\n        var enteredPart = value.replace(/[^0-9]/g, \"\"),\n            min = (opts.min && opts.min[targetProp] || value).toString(),\n            max = (opts.max && opts.max[targetProp] || value).toString();\n        correctedValue = enteredPart + (enteredPart < min.slice(0, enteredPart.length) ? min.slice(enteredPart.length) : enteredPart > max.slice(0, enteredPart.length) ? max.slice(enteredPart.length) : correctedValue.toString().slice(enteredPart.length));\n      }\n\n      return correctedValue;\n    }\n\n    function setValue(dateObj, value, opts) {\n      dateObj[targetProp] = extendProperty(value);\n      dateObj[\"raw\" + targetProp] = value;\n      if (dateOperation !== undefined) dateOperation.call(dateObj.date, targetProp == \"month\" ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\n    }\n\n    if (typeof mask === \"string\") {\n      while (match = getTokenizer(opts).exec(format)) {\n        var value = mask.slice(0, match[0].length);\n\n        if (formatCode.hasOwnProperty(match[0])) {\n          targetValidator = formatCode[match[0]][0];\n          targetProp = formatCode[match[0]][2];\n          dateOperation = formatCode[match[0]][1];\n          setValue(dateObj, value, opts);\n        }\n\n        mask = mask.slice(value.length);\n      }\n\n      return dateObj;\n    } else if (mask && typeof mask === \"object\" && mask.hasOwnProperty(\"date\")) {\n      return mask;\n    }\n\n    return undefined;\n  }\n\n  Inputmask.extendAliases({\n    datetime: {\n      mask: function (opts) {\n        formatCode.S = opts.i18n.ordinalSuffix.join(\"|\");\n        opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat;\n        opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat;\n        opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat;\n        opts.placeholder = opts.placeholder !== \"\" ? opts.placeholder : opts.inputFormat.replace(/[\\[\\]]/, \"\");\n        opts.regex = parse(opts.inputFormat, undefined, opts);\n        return null;\n      },\n      placeholder: \"\",\n      inputFormat: \"isoDateTime\",\n      displayFormat: undefined,\n      outputFormat: undefined,\n      min: null,\n      max: null,\n      i18n: {\n        dayNames: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n        monthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n        ordinalSuffix: [\"st\", \"nd\", \"rd\", \"th\"]\n      },\n      postValidation: function (buffer, pos, currentResult, opts) {\n        opts.min = analyseMask(opts.min, opts.inputFormat, opts);\n        opts.max = analyseMask(opts.max, opts.inputFormat, opts);\n        var result = currentResult,\n            dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\n\n        if (result && dateParts.date.getTime() === dateParts.date.getTime()) {\n          result = isValidDate(dateParts, result);\n          result = result && isDateInRange(dateParts, opts);\n        }\n\n        if (pos && result && currentResult.pos !== pos) {\n          return {\n            buffer: parse(opts.inputFormat, dateParts, opts),\n            refreshFromBuffer: {\n              start: pos,\n              end: currentResult.pos\n            }\n          };\n        }\n\n        return result;\n      },\n      onKeyDown: function (e, buffer, caretPos, opts) {\n        var input = this;\n\n        if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\n          var today = new Date(),\n              match,\n              date = \"\";\n\n          while (match = getTokenizer(opts).exec(opts.inputFormat)) {\n            if (match[0].charAt(0) === \"d\") {\n              date += pad(today.getDate(), match[0].length);\n            } else if (match[0].charAt(0) === \"m\") {\n              date += pad(today.getMonth() + 1, match[0].length);\n            } else if (match[0] === \"yyyy\") {\n              date += today.getFullYear().toString();\n            } else if (match[0].charAt(0) === \"y\") {\n              date += pad(today.getYear(), match[0].length);\n            }\n          }\n\n          input.inputmask._valueSet(date);\n\n          $(input).trigger(\"setvalue\");\n        }\n      },\n      onUnMask: function (maskedValue, unmaskedValue, opts) {\n        return parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, true);\n      },\n      casing: function (elem, test, pos, validPositions) {\n        if (test.nativeDef.indexOf(\"[ap]\") == 0) return elem.toLowerCase();\n        if (test.nativeDef.indexOf(\"[AP]\") == 0) return elem.toUpperCase();\n        return elem;\n      },\n      insertMode: false,\n      shiftPositions: false\n    }\n  });\n  return Inputmask;\n});","map":null,"metadata":{},"sourceType":"script"}